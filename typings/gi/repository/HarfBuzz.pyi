"""
Stub file for HarfBuzz. Autogenerated with gi-stubgen.
"""

import typing as _T  # noqa
from enum import Enum

from gi.repository import GLib, GObject

AAT_LAYOUT_NO_SELECTOR_INDEX = 65535
"""
Used when getting or setting AAT feature selectors. Indicates that
there is no selector index corresponding to the selector of interest.
"""

BUFFER_REPLACEMENT_CODEPOINT_DEFAULT = 65533
"""
The default code point for replacing invalid characters in a given encoding.
Set to U+FFFD REPLACEMENT CHARACTER.
"""

FEATURE_GLOBAL_START = 0

LANGUAGE_INVALID = 0

MAP_VALUE_INVALID = 4294967295

OT_LAYOUT_DEFAULT_LANGUAGE_INDEX = 65535

OT_LAYOUT_NO_FEATURE_INDEX = 65535

OT_LAYOUT_NO_SCRIPT_INDEX = 65535

OT_LAYOUT_NO_VARIATIONS_INDEX = 4294967295

OT_MAX_TAGS_PER_LANGUAGE = 3

OT_MAX_TAGS_PER_SCRIPT = 3

OT_VAR_NO_AXIS_INDEX = 4294967295

SET_VALUE_INVALID = 4294967295

UNICODE_MAX = 1114111

UNICODE_MAX_DECOMPOSITION_LEN = 19
"""
See Unicode 6.1 for details on the maximum decomposition length.
"""

VERSION_MAJOR = 2

VERSION_MICRO = 4

VERSION_MINOR = 7

VERSION_STRING = "2.7.4"


class aat_layout_feature_selector_t(Enum):
    """
    The selectors defined for specifying AAT feature settings.
    """
    INVALID = 65535
    ALL_TYPE_FEATURES_ON = 0
    ALL_TYPE_FEATURES_OFF = 1
    REQUIRED_LIGATURES_ON = 0
    REQUIRED_LIGATURES_OFF = 1
    COMMON_LIGATURES_ON = 2
    COMMON_LIGATURES_OFF = 3
    RARE_LIGATURES_ON = 4
    RARE_LIGATURES_OFF = 5
    LOGOS_ON = 6
    LOGOS_OFF = 7
    REBUS_PICTURES_ON = 8
    REBUS_PICTURES_OFF = 9
    DIPHTHONG_LIGATURES_ON = 10
    DIPHTHONG_LIGATURES_OFF = 11
    SQUARED_LIGATURES_ON = 12
    SQUARED_LIGATURES_OFF = 13
    ABBREV_SQUARED_LIGATURES_ON = 14
    ABBREV_SQUARED_LIGATURES_OFF = 15
    SYMBOL_LIGATURES_ON = 16
    SYMBOL_LIGATURES_OFF = 17
    CONTEXTUAL_LIGATURES_ON = 18
    CONTEXTUAL_LIGATURES_OFF = 19
    HISTORICAL_LIGATURES_ON = 20
    HISTORICAL_LIGATURES_OFF = 21
    UNCONNECTED = 0
    PARTIALLY_CONNECTED = 1
    CURSIVE = 2
    UPPER_AND_LOWER_CASE = 0
    ALL_CAPS = 1
    ALL_LOWER_CASE = 2
    SMALL_CAPS = 3
    INITIAL_CAPS = 4
    INITIAL_CAPS_AND_SMALL_CAPS = 5
    SUBSTITUTE_VERTICAL_FORMS_ON = 0
    SUBSTITUTE_VERTICAL_FORMS_OFF = 1
    LINGUISTIC_REARRANGEMENT_ON = 0
    LINGUISTIC_REARRANGEMENT_OFF = 1
    MONOSPACED_NUMBERS = 0
    PROPORTIONAL_NUMBERS = 1
    THIRD_WIDTH_NUMBERS = 2
    QUARTER_WIDTH_NUMBERS = 3
    WORD_INITIAL_SWASHES_ON = 0
    WORD_INITIAL_SWASHES_OFF = 1
    WORD_FINAL_SWASHES_ON = 2
    WORD_FINAL_SWASHES_OFF = 3
    LINE_INITIAL_SWASHES_ON = 4
    LINE_INITIAL_SWASHES_OFF = 5
    LINE_FINAL_SWASHES_ON = 6
    LINE_FINAL_SWASHES_OFF = 7
    NON_FINAL_SWASHES_ON = 8
    NON_FINAL_SWASHES_OFF = 9
    SHOW_DIACRITICS = 0
    HIDE_DIACRITICS = 1
    DECOMPOSE_DIACRITICS = 2
    NORMAL_POSITION = 0
    SUPERIORS = 1
    INFERIORS = 2
    ORDINALS = 3
    SCIENTIFIC_INFERIORS = 4
    NO_FRACTIONS = 0
    VERTICAL_FRACTIONS = 1
    DIAGONAL_FRACTIONS = 2
    PREVENT_OVERLAP_ON = 0
    PREVENT_OVERLAP_OFF = 1
    HYPHENS_TO_EM_DASH_ON = 0
    HYPHENS_TO_EM_DASH_OFF = 1
    HYPHEN_TO_EN_DASH_ON = 2
    HYPHEN_TO_EN_DASH_OFF = 3
    SLASHED_ZERO_ON = 4
    SLASHED_ZERO_OFF = 5
    FORM_INTERROBANG_ON = 6
    FORM_INTERROBANG_OFF = 7
    SMART_QUOTES_ON = 8
    SMART_QUOTES_OFF = 9
    PERIODS_TO_ELLIPSIS_ON = 10
    PERIODS_TO_ELLIPSIS_OFF = 11
    HYPHEN_TO_MINUS_ON = 0
    HYPHEN_TO_MINUS_OFF = 1
    ASTERISK_TO_MULTIPLY_ON = 2
    ASTERISK_TO_MULTIPLY_OFF = 3
    SLASH_TO_DIVIDE_ON = 4
    SLASH_TO_DIVIDE_OFF = 5
    INEQUALITY_LIGATURES_ON = 6
    INEQUALITY_LIGATURES_OFF = 7
    EXPONENTS_ON = 8
    EXPONENTS_OFF = 9
    MATHEMATICAL_GREEK_ON = 10
    MATHEMATICAL_GREEK_OFF = 11
    NO_ORNAMENTS = 0
    DINGBATS = 1
    PI_CHARACTERS = 2
    FLEURONS = 3
    DECORATIVE_BORDERS = 4
    INTERNATIONAL_SYMBOLS = 5
    MATH_SYMBOLS = 6
    NO_ALTERNATES = 0
    DESIGN_LEVEL1 = 0
    DESIGN_LEVEL2 = 1
    DESIGN_LEVEL3 = 2
    DESIGN_LEVEL4 = 3
    DESIGN_LEVEL5 = 4
    NO_STYLE_OPTIONS = 0
    DISPLAY_TEXT = 1
    ENGRAVED_TEXT = 2
    ILLUMINATED_CAPS = 3
    TITLING_CAPS = 4
    TALL_CAPS = 5
    TRADITIONAL_CHARACTERS = 0
    SIMPLIFIED_CHARACTERS = 1
    JIS1978_CHARACTERS = 2
    JIS1983_CHARACTERS = 3
    JIS1990_CHARACTERS = 4
    TRADITIONAL_ALT_ONE = 5
    TRADITIONAL_ALT_TWO = 6
    TRADITIONAL_ALT_THREE = 7
    TRADITIONAL_ALT_FOUR = 8
    TRADITIONAL_ALT_FIVE = 9
    EXPERT_CHARACTERS = 10
    JIS2004_CHARACTERS = 11
    HOJO_CHARACTERS = 12
    NLCCHARACTERS = 13
    TRADITIONAL_NAMES_CHARACTERS = 14
    LOWER_CASE_NUMBERS = 0
    UPPER_CASE_NUMBERS = 1
    PROPORTIONAL_TEXT = 0
    MONOSPACED_TEXT = 1
    HALF_WIDTH_TEXT = 2
    THIRD_WIDTH_TEXT = 3
    QUARTER_WIDTH_TEXT = 4
    ALT_PROPORTIONAL_TEXT = 5
    ALT_HALF_WIDTH_TEXT = 6
    NO_TRANSLITERATION = 0
    HANJA_TO_HANGUL = 1
    HIRAGANA_TO_KATAKANA = 2
    KATAKANA_TO_HIRAGANA = 3
    KANA_TO_ROMANIZATION = 4
    ROMANIZATION_TO_HIRAGANA = 5
    ROMANIZATION_TO_KATAKANA = 6
    HANJA_TO_HANGUL_ALT_ONE = 7
    HANJA_TO_HANGUL_ALT_TWO = 8
    HANJA_TO_HANGUL_ALT_THREE = 9
    NO_ANNOTATION = 0
    BOX_ANNOTATION = 1
    ROUNDED_BOX_ANNOTATION = 2
    CIRCLE_ANNOTATION = 3
    INVERTED_CIRCLE_ANNOTATION = 4
    PARENTHESIS_ANNOTATION = 5
    PERIOD_ANNOTATION = 6
    ROMAN_NUMERAL_ANNOTATION = 7
    DIAMOND_ANNOTATION = 8
    INVERTED_BOX_ANNOTATION = 9
    INVERTED_ROUNDED_BOX_ANNOTATION = 10
    FULL_WIDTH_KANA = 0
    PROPORTIONAL_KANA = 1
    FULL_WIDTH_IDEOGRAPHS = 0
    PROPORTIONAL_IDEOGRAPHS = 1
    HALF_WIDTH_IDEOGRAPHS = 2
    CANONICAL_COMPOSITION_ON = 0
    CANONICAL_COMPOSITION_OFF = 1
    COMPATIBILITY_COMPOSITION_ON = 2
    COMPATIBILITY_COMPOSITION_OFF = 3
    TRANSCODING_COMPOSITION_ON = 4
    TRANSCODING_COMPOSITION_OFF = 5
    NO_RUBY_KANA = 0
    RUBY_KANA = 1
    RUBY_KANA_ON = 2
    RUBY_KANA_OFF = 3
    NO_CJK_SYMBOL_ALTERNATIVES = 0
    CJK_SYMBOL_ALT_ONE = 1
    CJK_SYMBOL_ALT_TWO = 2
    CJK_SYMBOL_ALT_THREE = 3
    CJK_SYMBOL_ALT_FOUR = 4
    CJK_SYMBOL_ALT_FIVE = 5
    NO_IDEOGRAPHIC_ALTERNATIVES = 0
    IDEOGRAPHIC_ALT_ONE = 1
    IDEOGRAPHIC_ALT_TWO = 2
    IDEOGRAPHIC_ALT_THREE = 3
    IDEOGRAPHIC_ALT_FOUR = 4
    IDEOGRAPHIC_ALT_FIVE = 5
    CJK_VERTICAL_ROMAN_CENTERED = 0
    CJK_VERTICAL_ROMAN_HBASELINE = 1
    NO_CJK_ITALIC_ROMAN = 0
    CJK_ITALIC_ROMAN = 1
    CJK_ITALIC_ROMAN_ON = 2
    CJK_ITALIC_ROMAN_OFF = 3
    CASE_SENSITIVE_LAYOUT_ON = 0
    CASE_SENSITIVE_LAYOUT_OFF = 1
    CASE_SENSITIVE_SPACING_ON = 2
    CASE_SENSITIVE_SPACING_OFF = 3
    ALTERNATE_HORIZ_KANA_ON = 0
    ALTERNATE_HORIZ_KANA_OFF = 1
    ALTERNATE_VERT_KANA_ON = 2
    ALTERNATE_VERT_KANA_OFF = 3
    NO_STYLISTIC_ALTERNATES = 0
    STYLISTIC_ALT_ONE_ON = 2
    STYLISTIC_ALT_ONE_OFF = 3
    STYLISTIC_ALT_TWO_ON = 4
    STYLISTIC_ALT_TWO_OFF = 5
    STYLISTIC_ALT_THREE_ON = 6
    STYLISTIC_ALT_THREE_OFF = 7
    STYLISTIC_ALT_FOUR_ON = 8
    STYLISTIC_ALT_FOUR_OFF = 9
    STYLISTIC_ALT_FIVE_ON = 10
    STYLISTIC_ALT_FIVE_OFF = 11
    STYLISTIC_ALT_SIX_ON = 12
    STYLISTIC_ALT_SIX_OFF = 13
    STYLISTIC_ALT_SEVEN_ON = 14
    STYLISTIC_ALT_SEVEN_OFF = 15
    STYLISTIC_ALT_EIGHT_ON = 16
    STYLISTIC_ALT_EIGHT_OFF = 17
    STYLISTIC_ALT_NINE_ON = 18
    STYLISTIC_ALT_NINE_OFF = 19
    STYLISTIC_ALT_TEN_ON = 20
    STYLISTIC_ALT_TEN_OFF = 21
    STYLISTIC_ALT_ELEVEN_ON = 22
    STYLISTIC_ALT_ELEVEN_OFF = 23
    STYLISTIC_ALT_TWELVE_ON = 24
    STYLISTIC_ALT_TWELVE_OFF = 25
    STYLISTIC_ALT_THIRTEEN_ON = 26
    STYLISTIC_ALT_THIRTEEN_OFF = 27
    STYLISTIC_ALT_FOURTEEN_ON = 28
    STYLISTIC_ALT_FOURTEEN_OFF = 29
    STYLISTIC_ALT_FIFTEEN_ON = 30
    STYLISTIC_ALT_FIFTEEN_OFF = 31
    STYLISTIC_ALT_SIXTEEN_ON = 32
    STYLISTIC_ALT_SIXTEEN_OFF = 33
    STYLISTIC_ALT_SEVENTEEN_ON = 34
    STYLISTIC_ALT_SEVENTEEN_OFF = 35
    STYLISTIC_ALT_EIGHTEEN_ON = 36
    STYLISTIC_ALT_EIGHTEEN_OFF = 37
    STYLISTIC_ALT_NINETEEN_ON = 38
    STYLISTIC_ALT_NINETEEN_OFF = 39
    STYLISTIC_ALT_TWENTY_ON = 40
    STYLISTIC_ALT_TWENTY_OFF = 41
    CONTEXTUAL_ALTERNATES_ON = 0
    CONTEXTUAL_ALTERNATES_OFF = 1
    SWASH_ALTERNATES_ON = 2
    SWASH_ALTERNATES_OFF = 3
    CONTEXTUAL_SWASH_ALTERNATES_ON = 4
    CONTEXTUAL_SWASH_ALTERNATES_OFF = 5
    DEFAULT_LOWER_CASE = 0
    LOWER_CASE_SMALL_CAPS = 1
    LOWER_CASE_PETITE_CAPS = 2
    DEFAULT_UPPER_CASE = 0
    UPPER_CASE_SMALL_CAPS = 1
    UPPER_CASE_PETITE_CAPS = 2
    HALF_WIDTH_CJK_ROMAN = 0
    PROPORTIONAL_CJK_ROMAN = 1
    DEFAULT_CJK_ROMAN = 2
    FULL_WIDTH_CJK_ROMAN = 3

class aat_layout_feature_type_t(Enum):
    """
    The possible feature types defined for AAT shaping.
    """
    INVALID = 65535
    ALL_TYPOGRAPHIC = 0
    LIGATURES = 1
    CURISVE_CONNECTION = 2
    LETTER_CASE = 3
    VERTICAL_SUBSTITUTION = 4
    LINGUISTIC_REARRANGEMENT = 5
    NUMBER_SPACING = 6
    SMART_SWASH_TYPE = 8
    DIACRITICS_TYPE = 9
    VERTICAL_POSITION = 10
    FRACTIONS = 11
    OVERLAPPING_CHARACTERS_TYPE = 13
    TYPOGRAPHIC_EXTRAS = 14
    MATHEMATICAL_EXTRAS = 15
    ORNAMENT_SETS_TYPE = 16
    CHARACTER_ALTERNATIVES = 17
    DESIGN_COMPLEXITY_TYPE = 18
    STYLE_OPTIONS = 19
    CHARACTER_SHAPE = 20
    NUMBER_CASE = 21
    TEXT_SPACING = 22
    TRANSLITERATION = 23
    ANNOTATION_TYPE = 24
    KANA_SPACING_TYPE = 25
    IDEOGRAPHIC_SPACING_TYPE = 26
    UNICODE_DECOMPOSITION_TYPE = 27
    RUBY_KANA = 28
    CJK_SYMBOL_ALTERNATIVES_TYPE = 29
    IDEOGRAPHIC_ALTERNATIVES_TYPE = 30
    CJK_VERTICAL_ROMAN_PLACEMENT_TYPE = 31
    ITALIC_CJK_ROMAN = 32
    CASE_SENSITIVE_LAYOUT = 33
    ALTERNATE_KANA = 34
    STYLISTIC_ALTERNATIVES = 35
    CONTEXTUAL_ALTERNATIVES = 36
    LOWER_CASE = 37
    UPPER_CASE = 38
    LANGUAGE_TAG_TYPE = 39
    CJK_ROMAN_SPACING_TYPE = 103

class buffer_cluster_level_t(Enum):
    """
    Data type for holding HarfBuzz's clustering behavior options. The cluster level
    dictates one aspect of how HarfBuzz will treat non-base characters
    during shaping.

    In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES, non-base
    characters are merged into the cluster of the base character that precedes them.

    In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS, non-base characters are initially
    assigned their own cluster values, which are not merged into preceding base
    clusters. This allows HarfBuzz to perform additional operations like reorder
    sequences of adjacent marks.

    @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES is the default, because it maintains
    backward compatibility with older versions of HarfBuzz. New client programs that
    do not need to maintain such backward compatibility are recommended to use
    @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS instead of the default.
    """
    MONOTONE_GRAPHEMES = 0
    MONOTONE_CHARACTERS = 1
    CHARACTERS = 2
    DEFAULT = 0

class buffer_content_type_t(Enum):
    INVALID = 0
    UNICODE = 1
    GLYPHS = 2

class buffer_serialize_format_t(Enum):
    """
    The buffer serialization and de-serialization format used in
    hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().
    """
    TEXT = 1413830740
    JSON = 1246973774
    INVALID = 0

class direction_t(Enum):
    """
    The direction of a text segment or buffer.

    A segment can also be tested for horizontal or vertical
    orientation (irrespective of specific direction) with
    HB_DIRECTION_IS_HORIZONTAL() or HB_DIRECTION_IS_VERTICAL().
    """
    INVALID = 0
    LTR = 4
    RTL = 5
    TTB = 6
    BTT = 7

class memory_mode_t(Enum):
    """
    @HB_MEMORY_MODE_DUPLICATE
    @HB_MEMORY_MODE_READONLY
    @HB_MEMORY_MODE_WRITABLE
    @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE
    Data type holding the memory modes available to
    client programs.

    Regarding these various memory-modes:

    - In no case shall the HarfBuzz client modify memory
      that is passed to HarfBuzz in a blob.  If there is
      any such possibility, @HB_MEMORY_MODE_DUPLICATE should be used
      such that HarfBuzz makes a copy immediately,

    - Use @HB_MEMORY_MODE_READONLY otherwise, unless you really really
      really know what you are doing,

    - @HB_MEMORY_MODE_WRITABLE is appropriate if you really made a
      copy of data solely for the purpose of passing to
      HarfBuzz and doing that just once (no reuse!),

    - If the font is mmap()ed, it's okay to use
      @HB_MEMORY_READONLY_MAY_MAKE_WRITABLE, however, using that mode
      correctly is very tricky.  Use @HB_MEMORY_MODE_READONLY instead.
    """
    DUPLICATE = 0
    READONLY = 1
    WRITABLE = 2
    READONLY_MAY_MAKE_WRITABLE = 3

class ot_layout_baseline_tag_t(Enum):
    """
    Baseline tags from https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags
    """
    ROMAN = 1919905134
    HANGING = 1751215719
    IDEO_FACE_BOTTOM_OR_LEFT = 1768121954
    IDEO_FACE_TOP_OR_RIGHT = 1768121972
    IDEO_EMBOX_BOTTOM_OR_LEFT = 1768187247
    IDEO_EMBOX_TOP_OR_RIGHT = 1768191088
    MATH = 1835103336

class ot_layout_glyph_class_t(Enum):
    """
    The GDEF classes defined for glyphs.
    """
    UNCLASSIFIED = 0
    BASE_GLYPH = 1
    LIGATURE = 2
    MARK = 3
    COMPONENT = 4

class ot_math_constant_t(Enum):
    """
    The 'MATH' table constants specified at
    https://docs.microsoft.com/en-us/typography/opentype/spec/math
    """
    SCRIPT_PERCENT_SCALE_DOWN = 0
    SCRIPT_SCRIPT_PERCENT_SCALE_DOWN = 1
    DELIMITED_SUB_FORMULA_MIN_HEIGHT = 2
    DISPLAY_OPERATOR_MIN_HEIGHT = 3
    MATH_LEADING = 4
    AXIS_HEIGHT = 5
    ACCENT_BASE_HEIGHT = 6
    FLATTENED_ACCENT_BASE_HEIGHT = 7
    SUBSCRIPT_SHIFT_DOWN = 8
    SUBSCRIPT_TOP_MAX = 9
    SUBSCRIPT_BASELINE_DROP_MIN = 10
    SUPERSCRIPT_SHIFT_UP = 11
    SUPERSCRIPT_SHIFT_UP_CRAMPED = 12
    SUPERSCRIPT_BOTTOM_MIN = 13
    SUPERSCRIPT_BASELINE_DROP_MAX = 14
    SUB_SUPERSCRIPT_GAP_MIN = 15
    SUPERSCRIPT_BOTTOM_MAX_WITH_SUBSCRIPT = 16
    SPACE_AFTER_SCRIPT = 17
    UPPER_LIMIT_GAP_MIN = 18
    UPPER_LIMIT_BASELINE_RISE_MIN = 19
    LOWER_LIMIT_GAP_MIN = 20
    LOWER_LIMIT_BASELINE_DROP_MIN = 21
    STACK_TOP_SHIFT_UP = 22
    STACK_TOP_DISPLAY_STYLE_SHIFT_UP = 23
    STACK_BOTTOM_SHIFT_DOWN = 24
    STACK_BOTTOM_DISPLAY_STYLE_SHIFT_DOWN = 25
    STACK_GAP_MIN = 26
    STACK_DISPLAY_STYLE_GAP_MIN = 27
    STRETCH_STACK_TOP_SHIFT_UP = 28
    STRETCH_STACK_BOTTOM_SHIFT_DOWN = 29
    STRETCH_STACK_GAP_ABOVE_MIN = 30
    STRETCH_STACK_GAP_BELOW_MIN = 31
    FRACTION_NUMERATOR_SHIFT_UP = 32
    FRACTION_NUMERATOR_DISPLAY_STYLE_SHIFT_UP = 33
    FRACTION_DENOMINATOR_SHIFT_DOWN = 34
    FRACTION_DENOMINATOR_DISPLAY_STYLE_SHIFT_DOWN = 35
    FRACTION_NUMERATOR_GAP_MIN = 36
    FRACTION_NUM_DISPLAY_STYLE_GAP_MIN = 37
    FRACTION_RULE_THICKNESS = 38
    FRACTION_DENOMINATOR_GAP_MIN = 39
    FRACTION_DENOM_DISPLAY_STYLE_GAP_MIN = 40
    SKEWED_FRACTION_HORIZONTAL_GAP = 41
    SKEWED_FRACTION_VERTICAL_GAP = 42
    OVERBAR_VERTICAL_GAP = 43
    OVERBAR_RULE_THICKNESS = 44
    OVERBAR_EXTRA_ASCENDER = 45
    UNDERBAR_VERTICAL_GAP = 46
    UNDERBAR_RULE_THICKNESS = 47
    UNDERBAR_EXTRA_DESCENDER = 48
    RADICAL_VERTICAL_GAP = 49
    RADICAL_DISPLAY_STYLE_VERTICAL_GAP = 50
    RADICAL_RULE_THICKNESS = 51
    RADICAL_EXTRA_ASCENDER = 52
    RADICAL_KERN_BEFORE_DEGREE = 53
    RADICAL_KERN_AFTER_DEGREE = 54
    RADICAL_DEGREE_BOTTOM_RAISE_PERCENT = 55

class ot_math_kern_t(Enum):
    """
    The math kerning-table types defined for the four corners
    of a glyph.
    """
    TOP_RIGHT = 0
    TOP_LEFT = 1
    BOTTOM_RIGHT = 2
    BOTTOM_LEFT = 3

class ot_meta_tag_t(Enum):
    """
    Known metadata tags from https://docs.microsoft.com/en-us/typography/opentype/spec/meta
    """
    DESIGN_LANGUAGES = 1684827751
    SUPPORTED_LANGUAGES = 1936485991

class ot_metrics_tag_t(Enum):
    """
    From https://docs.microsoft.com/en-us/typography/opentype/spec/mvar#value-tags
    """
    HORIZONTAL_ASCENDER = 1751216995
    HORIZONTAL_DESCENDER = 1751413603
    HORIZONTAL_LINE_GAP = 1751934832
    HORIZONTAL_CLIPPING_ASCENT = 1751346273
    HORIZONTAL_CLIPPING_DESCENT = 1751346276
    VERTICAL_ASCENDER = 1986098019
    VERTICAL_DESCENDER = 1986294627
    VERTICAL_LINE_GAP = 1986815856
    HORIZONTAL_CARET_RISE = 1751347827
    HORIZONTAL_CARET_RUN = 1751347822
    HORIZONTAL_CARET_OFFSET = 1751347046
    VERTICAL_CARET_RISE = 1986228851
    VERTICAL_CARET_RUN = 1986228846
    VERTICAL_CARET_OFFSET = 1986228070
    X_HEIGHT = 2020108148
    CAP_HEIGHT = 1668311156
    SUBSCRIPT_EM_X_SIZE = 1935833203
    SUBSCRIPT_EM_Y_SIZE = 1935833459
    SUBSCRIPT_EM_X_OFFSET = 1935833199
    SUBSCRIPT_EM_Y_OFFSET = 1935833455
    SUPERSCRIPT_EM_X_SIZE = 1936750707
    SUPERSCRIPT_EM_Y_SIZE = 1936750963
    SUPERSCRIPT_EM_X_OFFSET = 1936750703
    SUPERSCRIPT_EM_Y_OFFSET = 1936750959
    STRIKEOUT_SIZE = 1937011315
    STRIKEOUT_OFFSET = 1937011311
    UNDERLINE_SIZE = 1970168947
    UNDERLINE_OFFSET = 1970168943

class script_t(Enum):
    """
    Data type for scripts. Each #hb_script_t's value is an #hb_tag_t corresponding
    to the four-letter values defined by [ISO 15924](https://unicode.org/iso15924/).

    See also the Script (sc) property of the Unicode Character Database.
    """
    COMMON = 1517910393
    INHERITED = 1516858984
    UNKNOWN = 1517976186
    ARABIC = 1098015074
    ARMENIAN = 1098018158
    BENGALI = 1113943655
    CYRILLIC = 1132032620
    DEVANAGARI = 1147500129
    GEORGIAN = 1197830002
    GREEK = 1198679403
    GUJARATI = 1198877298
    GURMUKHI = 1198879349
    HANGUL = 1214344807
    HAN = 1214344809
    HEBREW = 1214603890
    HIRAGANA = 1214870113
    KANNADA = 1265525857
    KATAKANA = 1264676449
    LAO = 1281453935
    LATIN = 1281455214
    MALAYALAM = 1298954605
    ORIYA = 1332902241
    TAMIL = 1415671148
    TELUGU = 1415933045
    THAI = 1416126825
    TIBETAN = 1416192628
    BOPOMOFO = 1114599535
    BRAILLE = 1114792297
    CANADIAN_SYLLABICS = 1130458739
    CHEROKEE = 1130915186
    ETHIOPIC = 1165256809
    KHMER = 1265134962
    MONGOLIAN = 1299148391
    MYANMAR = 1299803506
    OGHAM = 1332175213
    RUNIC = 1383427698
    SINHALA = 1399418472
    SYRIAC = 1400468067
    THAANA = 1416126817
    YI = 1500080489
    DESERET = 1148416628
    GOTHIC = 1198486632
    OLD_ITALIC = 1232363884
    BUHID = 1114990692
    HANUNOO = 1214344815
    TAGALOG = 1416064103
    TAGBANWA = 1415669602
    CYPRIOT = 1131442804
    LIMBU = 1281977698
    LINEAR_B = 1281977954
    OSMANYA = 1332964705
    SHAVIAN = 1399349623
    TAI_LE = 1415670885
    UGARITIC = 1432838514
    BUGINESE = 1114990441
    COPTIC = 1131376756
    GLAGOLITIC = 1198285159
    KHAROSHTHI = 1265131890
    NEW_TAI_LUE = 1415670901
    OLD_PERSIAN = 1483761007
    SYLOTI_NAGRI = 1400466543
    TIFINAGH = 1415999079
    BALINESE = 1113681001
    CUNEIFORM = 1483961720
    NKO = 1315663727
    PHAGS_PA = 1349017959
    PHOENICIAN = 1349021304
    CARIAN = 1130459753
    CHAM = 1130914157
    KAYAH_LI = 1264675945
    LEPCHA = 1281716323
    LYCIAN = 1283023721
    LYDIAN = 1283023977
    OL_CHIKI = 1332503403
    REJANG = 1382706791
    SAURASHTRA = 1398895986
    SUNDANESE = 1400204900
    VAI = 1449224553
    AVESTAN = 1098281844
    BAMUM = 1113681269
    EGYPTIAN_HIEROGLYPHS = 1164409200
    IMPERIAL_ARAMAIC = 1098018153
    INSCRIPTIONAL_PAHLAVI = 1349020777
    INSCRIPTIONAL_PARTHIAN = 1349678185
    JAVANESE = 1247901281
    KAITHI = 1265920105
    LISU = 1281979253
    MEETEI_MAYEK = 1299473769
    OLD_SOUTH_ARABIAN = 1398895202
    OLD_TURKIC = 1332898664
    SAMARITAN = 1398893938
    TAI_THAM = 1281453665
    TAI_VIET = 1415673460
    BATAK = 1113683051
    BRAHMI = 1114792296
    MANDAIC = 1298230884
    CHAKMA = 1130457965
    MEROITIC_CURSIVE = 1298494051
    MEROITIC_HIEROGLYPHS = 1298494063
    MIAO = 1349284452
    SHARADA = 1399353956
    SORA_SOMPENG = 1399812705
    TAKRI = 1415670642
    BASSA_VAH = 1113682803
    CAUCASIAN_ALBANIAN = 1097295970
    DUPLOYAN = 1148547180
    ELBASAN = 1164730977
    GRANTHA = 1198678382
    KHOJKI = 1265135466
    KHUDAWADI = 1399418468
    LINEAR_A = 1281977953
    MAHAJANI = 1298229354
    MANICHAEAN = 1298230889
    MENDE_KIKAKUI = 1298493028
    MODI = 1299145833
    MRO = 1299345263
    NABATAEAN = 1315070324
    OLD_NORTH_ARABIAN = 1315009122
    OLD_PERMIC = 1348825709
    PAHAWH_HMONG = 1215131239
    PALMYRENE = 1348562029
    PAU_CIN_HAU = 1348564323
    PSALTER_PAHLAVI = 1349020784
    SIDDHAM = 1399415908
    TIRHUTA = 1416196712
    WARANG_CITI = 1466004065
    AHOM = 1097363309
    ANATOLIAN_HIEROGLYPHS = 1215067511
    HATRAN = 1214346354
    MULTANI = 1299541108
    OLD_HUNGARIAN = 1215655527
    SIGNWRITING = 1399287415
    ADLAM = 1097100397
    BHAIKSUKI = 1114139507
    MARCHEN = 1298231907
    OSAGE = 1332963173
    TANGUT = 1415671399
    NEWA = 1315272545
    MASARAM_GONDI = 1198485101
    NUSHU = 1316186229
    SOYOMBO = 1399814511
    ZANABAZAR_SQUARE = 1516334690
    DOGRA = 1148151666
    GUNJALA_GONDI = 1198485095
    HANIFI_ROHINGYA = 1383032935
    MAKASAR = 1298230113
    MEDEFAIDRIN = 1298490470
    OLD_SOGDIAN = 1399809903
    SOGDIAN = 1399809892
    ELYMAIC = 1164736877
    NANDINAGARI = 1315008100
    NYIAKENG_PUACHUE_HMONG = 1215131248
    WANCHO = 1466132591
    CHORASMIAN = 1130918515
    DIVES_AKURU = 1147756907
    KHITAN_SMALL_SCRIPT = 1265202291
    YEZIDI = 1499822697
    INVALID = 0

class unicode_combining_class_t(Enum):
    """
    Data type for the Canonical_Combining_Class (ccc) property
    from the Unicode Character Database.

    <note>Note: newer versions of Unicode may add new values.
    Client programs should be ready to handle any value in the 0..254 range
    being returned from hb_unicode_combining_class().</note>
    """
    NOT_REORDERED = 0
    OVERLAY = 1
    NUKTA = 7
    KANA_VOICING = 8
    VIRAMA = 9
    CCC10 = 10
    CCC11 = 11
    CCC12 = 12
    CCC13 = 13
    CCC14 = 14
    CCC15 = 15
    CCC16 = 16
    CCC17 = 17
    CCC18 = 18
    CCC19 = 19
    CCC20 = 20
    CCC21 = 21
    CCC22 = 22
    CCC23 = 23
    CCC24 = 24
    CCC25 = 25
    CCC26 = 26
    CCC27 = 27
    CCC28 = 28
    CCC29 = 29
    CCC30 = 30
    CCC31 = 31
    CCC32 = 32
    CCC33 = 33
    CCC34 = 34
    CCC35 = 35
    CCC36 = 36
    CCC84 = 84
    CCC91 = 91
    CCC103 = 103
    CCC107 = 107
    CCC118 = 118
    CCC122 = 122
    CCC129 = 129
    CCC130 = 130
    CCC133 = 132
    ATTACHED_BELOW_LEFT = 200
    ATTACHED_BELOW = 202
    ATTACHED_ABOVE = 214
    ATTACHED_ABOVE_RIGHT = 216
    BELOW_LEFT = 218
    BELOW = 220
    BELOW_RIGHT = 222
    LEFT = 224
    RIGHT = 226
    ABOVE_LEFT = 228
    ABOVE = 230
    ABOVE_RIGHT = 232
    DOUBLE_BELOW = 233
    DOUBLE_ABOVE = 234
    IOTA_SUBSCRIPT = 240
    INVALID = 255

class unicode_general_category_t(Enum):
    """
    Data type for the "General_Category" (gc) property from
    the Unicode Character Database.
    """
    CONTROL = 0
    FORMAT = 1
    UNASSIGNED = 2
    PRIVATE_USE = 3
    SURROGATE = 4
    LOWERCASE_LETTER = 5
    MODIFIER_LETTER = 6
    OTHER_LETTER = 7
    TITLECASE_LETTER = 8
    UPPERCASE_LETTER = 9
    SPACING_MARK = 10
    ENCLOSING_MARK = 11
    NON_SPACING_MARK = 12
    DECIMAL_NUMBER = 13
    LETTER_NUMBER = 14
    OTHER_NUMBER = 15
    CONNECT_PUNCTUATION = 16
    DASH_PUNCTUATION = 17
    CLOSE_PUNCTUATION = 18
    FINAL_PUNCTUATION = 19
    INITIAL_PUNCTUATION = 20
    OTHER_PUNCTUATION = 21
    OPEN_PUNCTUATION = 22
    CURRENCY_SYMBOL = 23
    MODIFIER_SYMBOL = 24
    MATH_SYMBOL = 25
    OTHER_SYMBOL = 26
    LINE_SEPARATOR = 27
    PARAGRAPH_SEPARATOR = 28
    SPACE_SEPARATOR = 29

class buffer_diff_flags_t(Enum):
    EQUAL = 0
    CONTENT_TYPE_MISMATCH = 1
    LENGTH_MISMATCH = 2
    NOTDEF_PRESENT = 4
    DOTTED_CIRCLE_PRESENT = 8
    CODEPOINT_MISMATCH = 16
    CLUSTER_MISMATCH = 32
    GLYPH_FLAGS_MISMATCH = 64
    POSITION_MISMATCH = 128

class buffer_flags_t(Enum):
    DEFAULT = 0
    BOT = 1
    EOT = 2
    PRESERVE_DEFAULT_IGNORABLES = 4
    REMOVE_DEFAULT_IGNORABLES = 8
    DO_NOT_INSERT_DOTTED_CIRCLE = 16

class buffer_serialize_flags_t(Enum):
    """
    Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().
    """
    DEFAULT = 0
    NO_CLUSTERS = 1
    NO_POSITIONS = 2
    NO_GLYPH_NAMES = 4
    GLYPH_EXTENTS = 8
    GLYPH_FLAGS = 16
    NO_ADVANCES = 32

class glyph_flags_t(Enum):
    UNSAFE_TO_BREAK = 1
    DEFINED = 1

class ot_color_palette_flags_t(Enum):
    DEFAULT = 0
    USABLE_WITH_LIGHT_BACKGROUND = 1
    USABLE_WITH_DARK_BACKGROUND = 2

class ot_math_glyph_part_flags_t(Enum):
    """
    Flags for math glyph parts.
    """
    EXTENDER = 1

class ot_var_axis_flags_t(Enum):
    HIDDEN = 1


def blob_copy_writable_or_fail(blob: blob_t) -> blob_t:
    """
    Makes a writable copy of @blob.
    """
    ...

def blob_create(data: str, length: int, mode: memory_mode_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> blob_t:
    """
    Creates a new "blob" object wrapping @data.  The @mode parameter is used
    to negotiate ownership and lifecycle of @data.
    """
    ...

def blob_create_from_file(file_name: str) -> blob_t:
    """
    Creates a new blob containing the data from the
    specified binary font file.
    """
    ...

def blob_create_sub_blob(parent: blob_t, offset: int, length: int) -> blob_t:
    """
    Returns a blob that represents a range of bytes in @parent.  The new
    blob is always created with %HB_MEMORY_MODE_READONLY, meaning that it
    will never modify data in the parent blob.  The parent data is not
    expected to be modified, and will result in undefined behavior if it
    is.

    Makes @parent immutable.
    """
    ...

def blob_destroy(blob: blob_t) -> object:
    """
    Decreases the reference count on @blob, and if it reaches zero, destroys
    @blob, freeing all memory, possibly calling the destroy-callback the blob
    was created for if it has not been called already.

    See TODO:link object types for more information.
    """
    ...

def blob_get_data(blob: blob_t, length: int) -> object:
    """
    Fetches the data from a blob.
    """
    ...

def blob_get_data_writable(blob: blob_t, length: int) -> object:
    """
    Tries to make blob data writable (possibly copying it) and
    return pointer to data.

    Fails if blob has been made immutable, or if memory allocation
    fails.
    """
    ...

def blob_get_empty() -> blob_t:
    """
    Returns the singleton empty blob.

    See TODO:link object types for more information.
    """
    ...

def blob_get_length(blob: blob_t) -> int:
    """
    Fetches the length of a blob's data.
    """
    ...

def blob_get_user_data(blob: blob_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified font-functions structure.
    """
    ...

def blob_is_immutable(blob: blob_t) -> bool_t:
    """
    Tests whether a blob is immutable.
    """
    ...

def blob_make_immutable(blob: blob_t) -> object:
    """
    Makes a blob immutable.
    """
    ...

def blob_reference(blob: blob_t) -> blob_t:
    """
    Increases the reference count on @blob.

    See TODO:link object types for more information.
    """
    ...

def blob_set_user_data(blob: blob_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified blob.
    """
    ...

def buffer_add(buffer: buffer_t, codepoint: codepoint_t, cluster: int) -> object:
    """
    Appends a character with the Unicode value of @codepoint to @buffer, and
    gives it the initial cluster value of @cluster. Clusters can be any thing
    the client wants, they are usually used to refer to the index of the
    character in the input text stream and are output in
    #hb_glyph_info_t.cluster field.

    This function does not check the validity of @codepoint, it is up to the
    caller to ensure it is a valid Unicode code point.
    """
    ...

def buffer_add_codepoints(buffer: buffer_t, text: object, text_length: int, item_offset: int, item_length: int) -> object:
    """
    Appends characters from @text array to @buffer. The @item_offset is the
    position of the first character from @text that will be appended, and
    @item_length is the number of character. When shaping part of a larger text
    (e.g. a run of text from a paragraph), instead of passing just the substring
    corresponding to the run, it is preferable to pass the whole
    paragraph and specify the run start and length as @item_offset and
    @item_length, respectively, to give HarfBuzz the full context to be able,
    for example, to do cross-run Arabic shaping or properly handle combining
    marks at stat of run.

    This function does not check the validity of @text, it is up to the caller
    to ensure it contains a valid Unicode code points.
    """
    ...

def buffer_add_latin1(buffer: buffer_t, text: object, text_length: int, item_offset: int, item_length: int) -> object:
    """
    Similar to hb_buffer_add_codepoints(), but allows only access to first 256
    Unicode code points that can fit in 8-bit strings.

    <note>Has nothing to do with non-Unicode Latin-1 encoding.</note>
    """
    ...

def buffer_add_utf16(buffer: buffer_t, text: object, text_length: int, item_offset: int, item_length: int) -> object:
    """
    See hb_buffer_add_codepoints().

    Replaces invalid UTF-16 characters with the @buffer replacement code point,
    see hb_buffer_set_replacement_codepoint().
    """
    ...

def buffer_add_utf32(buffer: buffer_t, text: object, text_length: int, item_offset: int, item_length: int) -> object:
    """
    See hb_buffer_add_codepoints().

    Replaces invalid UTF-32 characters with the @buffer replacement code point,
    see hb_buffer_set_replacement_codepoint().
    """
    ...

def buffer_add_utf8(buffer: buffer_t, text: object, text_length: int, item_offset: int, item_length: int) -> object:
    """
    See hb_buffer_add_codepoints().

    Replaces invalid UTF-8 characters with the @buffer replacement code point,
    see hb_buffer_set_replacement_codepoint().
    """
    ...

def buffer_allocation_successful(buffer: buffer_t) -> bool_t:
    """
    Check if allocating memory for the buffer succeeded.
    """
    ...

def buffer_append(buffer: buffer_t, source: buffer_t, start: int, end: int) -> object:
    """
    Append (part of) contents of another buffer to this buffer.
    """
    ...

def buffer_clear_contents(buffer: buffer_t) -> object:
    """
    Similar to hb_buffer_reset(), but does not clear the Unicode functions and
    the replacement code point.
    """
    ...

def buffer_create() -> buffer_t:
    """
    Creates a new #hb_buffer_t with all properties to defaults.
    """
    ...

def buffer_deserialize_glyphs(buffer: buffer_t, buf: object, buf_len: int, end_ptr: str, font: font_t, format: buffer_serialize_format_t) -> bool_t:
    ...

def buffer_deserialize_unicode(buffer: buffer_t, buf: object, buf_len: int, end_ptr: str, format: buffer_serialize_format_t) -> bool_t:
    ...

def buffer_destroy(buffer: buffer_t) -> object:
    """
    Deallocate the @buffer.
    Decreases the reference count on @buffer by one. If the result is zero, then
    @buffer and all associated resources are freed. See hb_buffer_reference().
    """
    ...

def buffer_diff(buffer: buffer_t, reference: buffer_t, dottedcircle_glyph: codepoint_t, position_fuzz: int) -> buffer_diff_flags_t:
    """
    If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT
    and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most
    callers if just comparing two buffers is needed.
    """
    ...

def buffer_get_cluster_level(buffer: buffer_t) -> buffer_cluster_level_t:
    """
    Fetches the cluster level of a buffer. The #hb_buffer_cluster_level_t
    dictates one aspect of how HarfBuzz will treat non-base characters
    during shaping.
    """
    ...

def buffer_get_content_type(buffer: buffer_t) -> buffer_content_type_t:
    """
    Fetches the type of @buffer contents. Buffers are either empty, contain
    characters (before shaping), or contain glyphs (the result of shaping).
    """
    ...

def buffer_get_direction(buffer: buffer_t) -> direction_t:
    """
    See hb_buffer_set_direction()
    """
    ...

def buffer_get_empty() -> buffer_t:
    """
    Fetches an empty #hb_buffer_t.
    """
    ...

def buffer_get_flags(buffer: buffer_t) -> buffer_flags_t:
    """
    Fetches the #hb_buffer_flags_t of @buffer.
    """
    ...

def buffer_get_glyph_infos(buffer: buffer_t, length: int) -> object:
    """
    Returns @buffer glyph information array.  Returned pointer
    is valid as long as @buffer contents are not modified.
    """
    ...

def buffer_get_glyph_positions(buffer: buffer_t, length: int) -> object:
    """
    Returns @buffer glyph position array.  Returned pointer
    is valid as long as @buffer contents are not modified.
    """
    ...

def buffer_get_invisible_glyph(buffer: buffer_t) -> codepoint_t:
    """
    See hb_buffer_set_invisible_glyph().
    """
    ...

def buffer_get_language(buffer: buffer_t) -> language_t:
    """
    See hb_buffer_set_language().
    """
    ...

def buffer_get_length(buffer: buffer_t) -> int:
    """
    Returns the number of items in the buffer.
    """
    ...

def buffer_get_replacement_codepoint(buffer: buffer_t) -> codepoint_t:
    """
    Fetches the #hb_codepoint_t that replaces invalid entries for a given encoding
    when adding text to @buffer.
    """
    ...

def buffer_get_script(buffer: buffer_t) -> script_t:
    """
    Fetches the script of @buffer.
    """
    ...

def buffer_get_segment_properties(buffer: buffer_t, props: segment_properties_t) -> object:
    """
    Sets @props to the #hb_segment_properties_t of @buffer.
    """
    ...

def buffer_get_unicode_funcs(buffer: buffer_t) -> unicode_funcs_t:
    """
    Fetches the Unicode-functions structure of a buffer.
    """
    ...

def buffer_get_user_data(buffer: buffer_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified buffer.
    """
    ...

def buffer_guess_segment_properties(buffer: buffer_t) -> object:
    """
    Sets unset buffer segment properties based on buffer Unicode
    contents.  If buffer is not empty, it must have content type
    %HB_BUFFER_CONTENT_TYPE_UNICODE.

    If buffer script is not set (ie. is %HB_SCRIPT_INVALID), it
    will be set to the Unicode script of the first character in
    the buffer that has a script other than %HB_SCRIPT_COMMON,
    %HB_SCRIPT_INHERITED, and %HB_SCRIPT_UNKNOWN.

    Next, if buffer direction is not set (ie. is %HB_DIRECTION_INVALID),
    it will be set to the natural horizontal direction of the
    buffer script as returned by hb_script_get_horizontal_direction().
    If hb_script_get_horizontal_direction() returns %HB_DIRECTION_INVALID,
    then %HB_DIRECTION_LTR is used.

    Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),
    it will be set to the process's default language as returned by
    hb_language_get_default().  This may change in the future by
    taking buffer script into consideration when choosing a language.
    Note that hb_language_get_default() is NOT threadsafe the first time
    it is called.  See documentation for that function for details.
    """
    ...

def buffer_has_positions(buffer: buffer_t) -> bool_t:
    """
    Returns whether @buffer has glyph position data.
    A buffer gains position data when hb_buffer_get_glyph_positions() is called on it,
    and cleared of position data when hb_buffer_clear_contents() is called.
    """
    ...

def buffer_normalize_glyphs(buffer: buffer_t) -> object:
    """
    Reorders a glyph buffer to have canonical in-cluster glyph order / position.
    The resulting clusters should behave identical to pre-reordering clusters.

    <note>This has nothing to do with Unicode normalization.</note>
    """
    ...

def buffer_pre_allocate(buffer: buffer_t, size: int) -> bool_t:
    """
    Pre allocates memory for @buffer to fit at least @size number of items.
    """
    ...

def buffer_reference(buffer: buffer_t) -> buffer_t:
    """
    Increases the reference count on @buffer by one. This prevents @buffer from
    being destroyed until a matching call to hb_buffer_destroy() is made.
    """
    ...

def buffer_reset(buffer: buffer_t) -> object:
    """
    Resets the buffer to its initial status, as if it was just newly created
    with hb_buffer_create().
    """
    ...

def buffer_reverse(buffer: buffer_t) -> object:
    """
    Reverses buffer contents.
    """
    ...

def buffer_reverse_clusters(buffer: buffer_t) -> object:
    """
    Reverses buffer clusters.  That is, the buffer contents are
    reversed, then each cluster (consecutive items having the
    same cluster number) are reversed again.
    """
    ...

def buffer_reverse_range(buffer: buffer_t, start: int, end: int) -> object:
    """
    Reverses buffer contents between @start and @end.
    """
    ...

def buffer_serialize(buffer: buffer_t, start: int, end: int, buf: object, buf_size: int, buf_consumed: int, font: _T.Optional[font_t], format: buffer_serialize_format_t, flags: buffer_serialize_flags_t) -> int:
    """
    Serializes @buffer into a textual representation of its content, whether
    Unicode codepoints or glyph identifiers and positioning information. This is
    useful for showing the contents of the buffer, for example during debugging.
    See the documentation of hb_buffer_serialize_unicode() and
    hb_buffer_serialize_glyphs() for a description of the output format.
    """
    ...

def buffer_serialize_format_from_string(str: object, len: int) -> buffer_serialize_format_t:
    """
    Parses a string into an #hb_buffer_serialize_format_t. Does not check if
    @str is a valid buffer serialization format, use
    hb_buffer_serialize_list_formats() to get the list of supported formats.
    """
    ...

def buffer_serialize_format_to_string(format: buffer_serialize_format_t) -> str:
    """
    Converts @format to the string corresponding it, or %NULL if it is not a valid
    #hb_buffer_serialize_format_t.
    """
    ...

def buffer_serialize_glyphs(buffer: buffer_t, start: int, end: int, buf: object, buf_size: int, buf_consumed: int, font: _T.Optional[font_t], format: buffer_serialize_format_t, flags: buffer_serialize_flags_t) -> int:
    """
    Serializes @buffer into a textual representation of its glyph content,
    useful for showing the contents of the buffer, for example during debugging.
    There are currently two supported serialization formats:

    ## text
    A human-readable, plain text format.
    The serialized glyphs will look something like:

    ```
    [uni0651=0@518,0+0|uni0628=0+1897]
    ```

    - The serialized glyphs are delimited with `[` and `]`.
    - Glyphs are separated with `|`
    - Each glyph starts with glyph name, or glyph index if
      #HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES flag is set. Then,
      - If #HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS is not set, `=` then #hb_glyph_info_t.cluster.
      - If #HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS is not set, the #hb_glyph_position_t in the format:
        - If both #hb_glyph_position_t.x_offset and #hb_glyph_position_t.y_offset are not 0, `@x_offset,y_offset`. Then,
        - `+x_advance`, then `,y_advance` if #hb_glyph_position_t.y_advance is not 0. Then,
      - If #HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS is set, the #hb_glyph_extents_t in the format `<x_bearing,y_bearing,width,height>`

    ## json
    A machine-readable, structured format.
    The serialized glyphs will look something like:

    ```
    [{"g":"uni0651","cl":0,"dx":518,"dy":0,"ax":0,"ay":0},
    {"g":"uni0628","cl":0,"dx":0,"dy":0,"ax":1897,"ay":0}]
    ```

    Each glyph is a JSON object, with the following properties:
    - `g`: the glyph name or glyph index if
      #HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES flag is set.
    - `cl`: #hb_glyph_info_t.cluster if
      #HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS is not set.
    - `dx`,`dy`,`ax`,`ay`: #hb_glyph_position_t.x_offset, #hb_glyph_position_t.y_offset,
       #hb_glyph_position_t.x_advance and #hb_glyph_position_t.y_advance
       respectively, if #HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS is not set.
    - `xb`,`yb`,`w`,`h`: #hb_glyph_extents_t.x_bearing, #hb_glyph_extents_t.y_bearing,
       #hb_glyph_extents_t.width and #hb_glyph_extents_t.height respectively if
       #HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS is set.
    """
    ...

def buffer_serialize_list_formats() -> object:
    """
    Returns a list of supported buffer serialization formats.
    """
    ...

def buffer_serialize_unicode(buffer: buffer_t, start: int, end: int, buf: object, buf_size: int, buf_consumed: int, format: buffer_serialize_format_t, flags: buffer_serialize_flags_t) -> int:
    """
    Serializes @buffer into a textual representation of its content,
    when the buffer contains Unicode codepoints (i.e., before shaping). This is
    useful for showing the contents of the buffer, for example during debugging.
    There are currently two supported serialization formats:

    ## text
    A human-readable, plain text format.
    The serialized codepoints will look something like:

    ```
     <U+0651=0|U+0628=1>
    ```

    - Glyphs are separated with `|`
    - Unicode codepoints are expressed as zero-padded four (or more)
      digit hexadecimal numbers preceded by `U+`
    - If #HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS is not set, the cluster
      will be indicated with a `=` then #hb_glyph_info_t.cluster.

    ## json
    A machine-readable, structured format.
    The serialized codepoints will be a list of objects with the following
    properties:
    - `u`: the Unicode codepoint as a decimal integer
    - `cl`: #hb_glyph_info_t.cluster if
      #HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS is not set.

    For example:

    ```
    [{u:1617,cl:0},{u:1576,cl:1}]
    ```
    """
    ...

def buffer_set_cluster_level(buffer: buffer_t, cluster_level: buffer_cluster_level_t) -> object:
    """
    Sets the cluster level of a buffer. The #hb_buffer_cluster_level_t
    dictates one aspect of how HarfBuzz will treat non-base characters
    during shaping.
    """
    ...

def buffer_set_content_type(buffer: buffer_t, content_type: buffer_content_type_t) -> object:
    """
    Sets the type of @buffer contents. Buffers are either empty, contain
    characters (before shaping), or contain glyphs (the result of shaping).
    """
    ...

def buffer_set_direction(buffer: buffer_t, direction: direction_t) -> object:
    """
    Set the text flow direction of the buffer. No shaping can happen without
    setting @buffer direction, and it controls the visual direction for the
    output glyphs; for RTL direction the glyphs will be reversed. Many layout
    features depend on the proper setting of the direction, for example,
    reversing RTL text before shaping, then shaping with LTR direction is not
    the same as keeping the text in logical order and shaping with RTL
    direction.
    """
    ...

def buffer_set_flags(buffer: buffer_t, flags: buffer_flags_t) -> object:
    """
    Sets @buffer flags to @flags. See #hb_buffer_flags_t.
    """
    ...

def buffer_set_invisible_glyph(buffer: buffer_t, invisible: codepoint_t) -> object:
    """
    Sets the #hb_codepoint_t that replaces invisible characters in
    the shaping result.  If set to zero (default), the glyph for the
    U+0020 SPACE character is used.  Otherwise, this value is used
    verbatim.
    """
    ...

def buffer_set_language(buffer: buffer_t, language: language_t) -> object:
    """
    Sets the language of @buffer to @language.

    Languages are crucial for selecting which OpenType feature to apply to the
    buffer which can result in applying language-specific behaviour. Languages
    are orthogonal to the scripts, and though they are related, they are
    different concepts and should not be confused with each other.

    Use hb_language_from_string() to convert from BCP 47 language tags to
    #hb_language_t.
    """
    ...

def buffer_set_length(buffer: buffer_t, length: int) -> bool_t:
    """
    Similar to hb_buffer_pre_allocate(), but clears any new items added at the
    end.
    """
    ...

def buffer_set_message_func(buffer: buffer_t, func: buffer_message_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    ...

def buffer_set_replacement_codepoint(buffer: buffer_t, replacement: codepoint_t) -> object:
    """
    Sets the #hb_codepoint_t that replaces invalid entries for a given encoding
    when adding text to @buffer.

    Default is %HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT.
    """
    ...

def buffer_set_script(buffer: buffer_t, script: script_t) -> object:
    """
    Sets the script of @buffer to @script.

    Script is crucial for choosing the proper shaping behaviour for scripts that
    require it (e.g. Arabic) and the which OpenType features defined in the font
    to be applied.

    You can pass one of the predefined #hb_script_t values, or use
    hb_script_from_string() or hb_script_from_iso15924_tag() to get the
    corresponding script from an ISO 15924 script tag.
    """
    ...

def buffer_set_segment_properties(buffer: buffer_t, props: segment_properties_t) -> object:
    """
    Sets the segment properties of the buffer, a shortcut for calling
    hb_buffer_set_direction(), hb_buffer_set_script() and
    hb_buffer_set_language() individually.
    """
    ...

def buffer_set_unicode_funcs(buffer: buffer_t, unicode_funcs: unicode_funcs_t) -> object:
    """
    Sets the Unicode-functions structure of a buffer to
    @unicode_funcs.
    """
    ...

def buffer_set_user_data(buffer: buffer_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified buffer.
    """
    ...

def color_get_alpha(color: color_t) -> int:
    """
    color: a #hb_color_t we are interested in its channels.
    """
    ...

def color_get_blue(color: color_t) -> int:
    """
    color: a #hb_color_t we are interested in its channels.
    """
    ...

def color_get_green(color: color_t) -> int:
    """
    color: a #hb_color_t we are interested in its channels.
    """
    ...

def color_get_red(color: color_t) -> int:
    """
    color: a #hb_color_t we are interested in its channels.
    """
    ...

def direction_from_string(str: object, len: int) -> direction_t:
    """
    Converts a string to an #hb_direction_t.

    Matching is loose and applies only to the first letter. For
    examples, "LTR" and "left-to-right" will both return #HB_DIRECTION_LTR.

    Unmatched strings will return #HB_DIRECTION_INVALID.
    """
    ...

def direction_to_string(direction: direction_t) -> str:
    """
    Converts an #hb_direction_t to a string.
    """
    ...

def face_builder_add_table(face: face_t, tag: tag_t, blob: blob_t) -> bool_t:
    """
    Add table for @tag with data provided by @blob to the face.  @face must
    be created using hb_face_builder_create().
    """
    ...

def face_builder_create() -> face_t:
    """
    Creates a #hb_face_t that can be used with hb_face_builder_add_table().
    After tables are added to the face, it can be compiled to a binary
    font file by calling hb_face_reference_blob().
    """
    ...

def face_collect_unicodes(face: face_t, out: set_t) -> object:
    """
    Collects all of the Unicode characters covered by @face and adds
    them to the #hb_set_t set @out.
    """
    ...

def face_collect_variation_selectors(face: face_t, out: set_t) -> object:
    """
    Collects all Unicode "Variation Selector" characters covered by @face and adds
    them to the #hb_set_t set @out.
    """
    ...

def face_collect_variation_unicodes(face: face_t, variation_selector: codepoint_t, out: set_t) -> object:
    """
    Collects all Unicode characters for @variation_selector covered by @face and adds
    them to the #hb_set_t set @out.
    """
    ...

def face_count(blob: blob_t) -> int:
    """
    Fetches the number of faces in a blob.
    """
    ...

def face_create(blob: blob_t, index: int) -> face_t:
    """
    Constructs a new face object from the specified blob and
    a face index into that blob. This is used for blobs of
    file formats such as Dfont and TTC that can contain more
    than one face.
    """
    ...

def face_create_for_tables(reference_table_func: reference_table_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> face_t:
    """
    Variant of hb_face_create(), built for those cases where it is more
    convenient to provide data for individual tables instead of the whole font
    data. With the caveat that hb_face_get_table_tags() does not currently work
    with faces created this way.

    Creates a new face object from the specified @user_data and @reference_table_func,
    with the @destroy callback.
    """
    ...

def face_destroy(face: face_t) -> object:
    """
    Decreases the reference count on a face object. When the
    reference count reaches zero, the face is destroyed,
    freeing all memory.
    """
    ...

def face_get_empty() -> face_t:
    """
    Fetches the singleton empty face object.
    """
    ...

def face_get_glyph_count(face: face_t) -> int:
    """
    Fetches the glyph-count value of the specified face object.
    """
    ...

def face_get_index(face: face_t) -> int:
    """
    Fetches the face-index corresponding to the given face.

    <note>Note: face indices within a collection are zero-based.</note>
    """
    ...

def face_get_table_tags(face: face_t, start_offset: int, table_count: int, table_tags: object) -> int:
    """
    Fetches a list of all table tags for a face, if possible. The list returned will
    begin at the offset provided
    """
    ...

def face_get_upem(face: face_t) -> int:
    """
    Fetches the units-per-em (upem) value of the specified face object.
    """
    ...

def face_get_user_data(face: face_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified face object.
    """
    ...

def face_is_immutable(face: face_t) -> bool_t:
    """
    Tests whether the given face object is immutable.
    """
    ...

def face_make_immutable(face: face_t) -> object:
    """
    Makes the given face object immutable.
    """
    ...

def face_reference(face: face_t) -> face_t:
    """
    Increases the reference count on a face object.
    """
    ...

def face_reference_blob(face: face_t) -> blob_t:
    """
    Fetches a pointer to the binary blob that contains the
    specified face. Returns an empty blob if referencing face data is not
    possible.
    """
    ...

def face_reference_table(face: face_t, tag: tag_t) -> blob_t:
    """
    Fetches a reference to the specified table within
    the specified face.
    """
    ...

def face_set_glyph_count(face: face_t, glyph_count: int) -> object:
    """
    Sets the glyph count for a face object to the specified value.
    """
    ...

def face_set_index(face: face_t, index: int) -> object:
    """
    Assigns the specified face-index to @face. Fails if the
    face is immutable.

    <note>Note: face indices within a collection are zero-based.</note>
    """
    ...

def face_set_upem(face: face_t, upem: int) -> object:
    """
    Sets the units-per-em (upem) for a face object to the specified value.
    """
    ...

def face_set_user_data(face: face_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the given face object.
    """
    ...

def feature_from_string(str: object, len: int, feature: feature_t) -> bool_t:
    """
    Parses a string into a #hb_feature_t.

    The format for specifying feature strings follows. All valid CSS
    font-feature-settings values other than 'normal' and the global values are
    also accepted, though not documented below. CSS string escapes are not
    supported.

    The range indices refer to the positions between Unicode characters. The
    position before the first character is always 0.

    The format is Python-esque.  Here is how it all works:

    <informaltable pgwide='1' align='left' frame='none'>
    <tgroup cols='5'>
    <thead>
    <row><entry>Syntax</entry>    <entry>Value</entry> <entry>Start</entry> <entry>End</entry></row>
    </thead>
    <tbody>
    <row><entry>Setting value:</entry></row>
    <row><entry>kern</entry>      <entry>1</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature on</entry></row>
    <row><entry>+kern</entry>     <entry>1</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature on</entry></row>
    <row><entry>-kern</entry>     <entry>0</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature off</entry></row>
    <row><entry>kern=0</entry>    <entry>0</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature off</entry></row>
    <row><entry>kern=1</entry>    <entry>1</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature on</entry></row>
    <row><entry>aalt=2</entry>    <entry>2</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Choose 2nd alternate</entry></row>
    <row><entry>Setting index:</entry></row>
    <row><entry>kern[]</entry>    <entry>1</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature on</entry></row>
    <row><entry>kern[:]</entry>   <entry>1</entry>     <entry>0</entry>      <entry>∞</entry>   <entry>Turn feature on</entry></row>
    <row><entry>kern[5:]</entry>  <entry>1</entry>     <entry>5</entry>      <entry>∞</entry>   <entry>Turn feature on, partial</entry></row>
    <row><entry>kern[:5]</entry>  <entry>1</entry>     <entry>0</entry>      <entry>5</entry>   <entry>Turn feature on, partial</entry></row>
    <row><entry>kern[3:5]</entry> <entry>1</entry>     <entry>3</entry>      <entry>5</entry>   <entry>Turn feature on, range</entry></row>
    <row><entry>kern[3]</entry>   <entry>1</entry>     <entry>3</entry>      <entry>3+1</entry> <entry>Turn feature on, single char</entry></row>
    <row><entry>Mixing it all:</entry></row>
    <row><entry>aalt[3:5]=2</entry> <entry>2</entry>   <entry>3</entry>      <entry>5</entry>   <entry>Turn 2nd alternate on for range</entry></row>
    </tbody>
    </tgroup>
    </informaltable>
    """
    ...

def feature_to_string(feature: feature_t, buf: object, size: int) -> object:
    """
    Converts a #hb_feature_t into a %NULL-terminated string in the format
    understood by hb_feature_from_string(). The client in responsible for
    allocating big enough size for @buf, 128 bytes is more than enough.
    """
    ...

def font_add_glyph_origin_for_direction(font: font_t, glyph: codepoint_t, direction: direction_t, x: position_t, y: position_t) -> object:
    """
    Adds the origin coordinates to an (X,Y) point coordinate, in
    the specified glyph ID in the specified font.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_create(face: face_t) -> font_t:
    """
    Constructs a new font object from the specified face.
    """
    ...

def font_create_sub_font(parent: font_t) -> font_t:
    """
    Constructs a sub-font font object from the specified @parent font,
    replicating the parent's properties.
    """
    ...

def font_destroy(font: font_t) -> object:
    """
    Decreases the reference count on the given font object. When the
    reference count reaches zero, the font is destroyed,
    freeing all memory.
    """
    ...

def font_funcs_create() -> font_funcs_t:
    """
    Creates a new #hb_font_funcs_t structure of font functions.
    """
    ...

def font_funcs_destroy(ffuncs: font_funcs_t) -> object:
    """
    Decreases the reference count on a font-functions structure. When
    the reference count reaches zero, the font-functions structure is
    destroyed, freeing all memory.
    """
    ...

def font_funcs_get_empty() -> font_funcs_t:
    """
    Fetches an empty font-functions structure.
    """
    ...

def font_funcs_get_user_data(ffuncs: font_funcs_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified font-functions structure.
    """
    ...

def font_funcs_is_immutable(ffuncs: font_funcs_t) -> bool_t:
    """
    Tests whether a font-functions structure is immutable.
    """
    ...

def font_funcs_make_immutable(ffuncs: font_funcs_t) -> object:
    """
    Makes a font-functions structure immutable.
    """
    ...

def font_funcs_reference(ffuncs: font_funcs_t) -> font_funcs_t:
    """
    Increases the reference count on a font-functions structure.
    """
    ...

def font_funcs_set_font_h_extents_func(ffuncs: font_funcs_t, func: font_get_font_h_extents_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_font_h_extents_func_t.
    """
    ...

def font_funcs_set_font_v_extents_func(ffuncs: font_funcs_t, func: font_get_font_v_extents_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_font_v_extents_func_t.
    """
    ...

def font_funcs_set_glyph_contour_point_func(ffuncs: font_funcs_t, func: font_get_glyph_contour_point_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_contour_point_func_t.
    """
    ...

def font_funcs_set_glyph_extents_func(ffuncs: font_funcs_t, func: font_get_glyph_extents_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_extents_func_t.
    """
    ...

def font_funcs_set_glyph_from_name_func(ffuncs: font_funcs_t, func: font_get_glyph_from_name_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_from_name_func_t.
    """
    ...

def font_funcs_set_glyph_func(ffuncs: font_funcs_t, func: font_get_glyph_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Deprecated.  Use hb_font_funcs_set_nominal_glyph_func() and
    hb_font_funcs_set_variation_glyph_func() instead.
    """
    ...

def font_funcs_set_glyph_h_advance_func(ffuncs: font_funcs_t, func: font_get_glyph_h_advance_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_h_advance_func_t.
    """
    ...

def font_funcs_set_glyph_h_advances_func(ffuncs: font_funcs_t, func: font_get_glyph_h_advances_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_h_advances_func_t.
    """
    ...

def font_funcs_set_glyph_h_kerning_func(ffuncs: font_funcs_t, func: font_get_glyph_h_kerning_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    ...

def font_funcs_set_glyph_h_origin_func(ffuncs: font_funcs_t, func: font_get_glyph_h_origin_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_h_origin_func_t.
    """
    ...

def font_funcs_set_glyph_name_func(ffuncs: font_funcs_t, func: font_get_glyph_name_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_name_func_t.
    """
    ...

def font_funcs_set_glyph_v_advance_func(ffuncs: font_funcs_t, func: font_get_glyph_v_advance_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_v_advance_func_t.
    """
    ...

def font_funcs_set_glyph_v_advances_func(ffuncs: font_funcs_t, func: font_get_glyph_v_advances_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_v_advances_func_t.
    """
    ...

def font_funcs_set_glyph_v_kerning_func(ffuncs: font_funcs_t, func: font_get_glyph_v_kerning_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    ...

def font_funcs_set_glyph_v_origin_func(ffuncs: font_funcs_t, func: font_get_glyph_v_origin_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_glyph_v_origin_func_t.
    """
    ...

def font_funcs_set_nominal_glyph_func(ffuncs: font_funcs_t, func: font_get_nominal_glyph_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_nominal_glyph_func_t.
    """
    ...

def font_funcs_set_nominal_glyphs_func(ffuncs: font_funcs_t, func: font_get_nominal_glyphs_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_nominal_glyphs_func_t.
    """
    ...

def font_funcs_set_user_data(ffuncs: font_funcs_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified font-functions structure.
    """
    ...

def font_funcs_set_variation_glyph_func(ffuncs: font_funcs_t, func: font_get_variation_glyph_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_font_get_variation_glyph_func_t.
    """
    ...

def font_get_empty() -> font_t:
    """
    Fetches the empty font object.
    """
    ...

def font_get_extents_for_direction(font: font_t, direction: direction_t, extents: font_extents_t) -> object:
    """
    Fetches the extents for a font in a text segment of the
    specified direction.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_face(font: font_t) -> face_t:
    """
    Fetches the face associated with the specified font object.
    """
    ...

def font_get_glyph(font: font_t, unicode: codepoint_t, variation_selector: codepoint_t, glyph: codepoint_t) -> bool_t:
    """
    Fetches the glyph ID for a Unicode code point in the specified
    font, with an optional variation selector.

    If @variation_selector is 0, calls hb_font_get_nominal_glyph();
    otherwise calls hb_font_get_variation_glyph().
    """
    ...

def font_get_glyph_advance_for_direction(font: font_t, glyph: codepoint_t, direction: direction_t, x: position_t, y: position_t) -> object:
    """
    Fetches the advance for a glyph ID from the specified font,
    in a text segment of the specified direction.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_glyph_advances_for_direction(font: font_t, direction: direction_t, count: int, first_glyph: codepoint_t, glyph_stride: int, first_advance: position_t, advance_stride: int) -> object:
    """
    Fetches the advances for a sequence of glyph IDs in the specified
    font, in a text segment of the specified direction.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_glyph_contour_point(font: font_t, glyph: codepoint_t, point_index: int, x: position_t, y: position_t) -> bool_t:
    """
    Fetches the (x,y) coordinates of a specified contour-point index
    in the specified glyph, within the specified font.
    """
    ...

def font_get_glyph_contour_point_for_origin(font: font_t, glyph: codepoint_t, point_index: int, direction: direction_t, x: position_t, y: position_t) -> bool_t:
    """
    Fetches the (X,Y) coordinates of a specified contour-point index
    in the specified glyph ID in the specified font, with respect
    to the origin in a text segment in the specified direction.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_glyph_extents(font: font_t, glyph: codepoint_t, extents: glyph_extents_t) -> bool_t:
    """
    Fetches the #hb_glyph_extents_t data for a glyph ID
    in the specified font.
    """
    ...

def font_get_glyph_extents_for_origin(font: font_t, glyph: codepoint_t, direction: direction_t, extents: glyph_extents_t) -> bool_t:
    """
    Fetches the #hb_glyph_extents_t data for a glyph ID
    in the specified font, with respect to the origin in
    a text segment in the specified direction.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_glyph_from_name(font: font_t, name: object, len: int, glyph: codepoint_t) -> bool_t:
    """
    Fetches the glyph ID that corresponds to a name string in the specified @font.

    <note>Note: @len == -1 means the name string is null-terminated.</note>
    """
    ...

def font_get_glyph_h_advance(font: font_t, glyph: codepoint_t) -> position_t:
    """
    Fetches the advance for a glyph ID in the specified font,
    for horizontal text segments.
    """
    ...

def font_get_glyph_h_advances(font: font_t, count: int, first_glyph: codepoint_t, glyph_stride: int, first_advance: position_t, advance_stride: int) -> object:
    """
    Fetches the advances for a sequence of glyph IDs in the specified
    font, for horizontal text segments.
    """
    ...

def font_get_glyph_h_kerning(font: font_t, left_glyph: codepoint_t, right_glyph: codepoint_t) -> position_t:
    """
    Fetches the kerning-adjustment value for a glyph-pair in
    the specified font, in horizontal text segments.

    <note>It handles legacy kerning only (as returned by the corresponding
    #hb_font_funcs_t function).</note>
    """
    ...

def font_get_glyph_h_origin(font: font_t, glyph: codepoint_t, x: position_t, y: position_t) -> bool_t:
    """
    Fetches the (X,Y) coordinates of the origin for a glyph ID
    in the specified font, for horizontal text segments.
    """
    ...

def font_get_glyph_kerning_for_direction(font: font_t, first_glyph: codepoint_t, second_glyph: codepoint_t, direction: direction_t, x: position_t, y: position_t) -> object:
    """
    Fetches the kerning-adjustment value for a glyph-pair in the specified font.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_glyph_name(font: font_t, glyph: codepoint_t, name: object, size: int) -> bool_t:
    """
    Fetches the glyph-name string for a glyph ID in the specified @font.
    """
    ...

def font_get_glyph_origin_for_direction(font: font_t, glyph: codepoint_t, direction: direction_t, x: position_t, y: position_t) -> object:
    """
    Fetches the (X,Y) coordinates of the origin for a glyph in
    the specified font.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def font_get_glyph_v_advance(font: font_t, glyph: codepoint_t) -> position_t:
    """
    Fetches the advance for a glyph ID in the specified font,
    for vertical text segments.
    """
    ...

def font_get_glyph_v_advances(font: font_t, count: int, first_glyph: codepoint_t, glyph_stride: int, first_advance: position_t, advance_stride: int) -> object:
    """
    Fetches the advances for a sequence of glyph IDs in the specified
    font, for vertical text segments.
    """
    ...

def font_get_glyph_v_kerning(font: font_t, top_glyph: codepoint_t, bottom_glyph: codepoint_t) -> position_t:
    """
    Fetches the kerning-adjustment value for a glyph-pair in
    the specified font, in vertical text segments.

    <note>It handles legacy kerning only (as returned by the corresponding
    #hb_font_funcs_t function).</note>
    """
    ...

def font_get_glyph_v_origin(font: font_t, glyph: codepoint_t, x: position_t, y: position_t) -> bool_t:
    """
    Fetches the (X,Y) coordinates of the origin for a glyph ID
    in the specified font, for vertical text segments.
    """
    ...

def font_get_h_extents(font: font_t, extents: font_extents_t) -> bool_t:
    """
    Fetches the extents for a specified font, in horizontal
    text segments.
    """
    ...

def font_get_nominal_glyph(font: font_t, unicode: codepoint_t, glyph: codepoint_t) -> bool_t:
    """
    Fetches the nominal glyph ID for a Unicode code point in the
    specified font.

    This version of the function should not be used to fetch glyph IDs
    for code points modified by variation selectors. For variation-selector
    support, user hb_font_get_variation_glyph() or use hb_font_get_glyph().
    """
    ...

def font_get_nominal_glyphs(font: font_t, count: int, first_unicode: codepoint_t, unicode_stride: int, first_glyph: codepoint_t, glyph_stride: int) -> int:
    ...

def font_get_parent(font: font_t) -> font_t:
    """
    Fetches the parent font of @font.
    """
    ...

def font_get_ppem(font: font_t, x_ppem: int, y_ppem: int) -> object:
    """
    Fetches the horizontal and vertical points-per-em (ppem) of a font.
    """
    ...

def font_get_ptem(font: font_t) -> float:
    """
    Fetches the "point size" of a font. Used in CoreText to
    implement optical sizing.
    """
    ...

def font_get_scale(font: font_t, x_scale: int, y_scale: int) -> object:
    """
    Fetches the horizontal and vertical scale of a font.
    """
    ...

def font_get_user_data(font: font_t, key: user_data_key_t) -> object:
    """
    Fetches the user-data object associated with the specified key,
    attached to the specified font object.
    """
    ...

def font_get_v_extents(font: font_t, extents: font_extents_t) -> bool_t:
    """
    Fetches the extents for a specified font, in vertical
    text segments.
    """
    ...

def font_get_var_coords_normalized(font: font_t, length: int) -> int:
    """
    Fetches the list of normalized variation coordinates currently
    set on a font.

    Return value is valid as long as variation coordinates of the font
    are not modified.
    """
    ...

def font_get_variation_glyph(font: font_t, unicode: codepoint_t, variation_selector: codepoint_t, glyph: codepoint_t) -> bool_t:
    """
    Fetches the glyph ID for a Unicode code point when followed by
    by the specified variation-selector code point, in the specified
    font.
    """
    ...

def font_glyph_from_string(font: font_t, s: object, len: int, glyph: codepoint_t) -> bool_t:
    """
    Fetches the glyph ID from @font that matches the specified string.
    Strings of the format `gidDDD` or `uniUUUU` are parsed automatically.

    <note>Note: @len == -1 means the string is null-terminated.</note>
    """
    ...

def font_glyph_to_string(font: font_t, glyph: codepoint_t, s: object, size: int) -> object:
    """
    Fetches the name of the specified glyph ID in @font and returns
    it in string @s.

    If the glyph ID has no name in @font, a string of the form `gidDDD` is
    generated, with `DDD` being the glyph ID.
    """
    ...

def font_is_immutable(font: font_t) -> bool_t:
    """
    Tests whether a font object is immutable.
    """
    ...

def font_make_immutable(font: font_t) -> object:
    """
    Makes @font immutable.
    """
    ...

def font_reference(font: font_t) -> font_t:
    """
    Increases the reference count on the given font object.
    """
    ...

def font_set_face(font: font_t, face: face_t) -> object:
    """
    Sets @face as the font-face value of @font.
    """
    ...

def font_set_funcs(font: font_t, klass: font_funcs_t, font_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Replaces the font-functions structure attached to a font, updating
    the font's user-data with @font-data and the @destroy callback.
    """
    ...

def font_set_funcs_data(font: font_t, font_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Replaces the user data attached to a font, updating the font's
    @destroy callback.
    """
    ...

def font_set_parent(font: font_t, parent: font_t) -> object:
    """
    Sets the parent font of @font.
    """
    ...

def font_set_ppem(font: font_t, x_ppem: int, y_ppem: int) -> object:
    """
    Sets the horizontal and vertical pixels-per-em (ppem) of a font.
    """
    ...

def font_set_ptem(font: font_t, ptem: float) -> object:
    """
    Sets the "point size" of a font. Set to zero to unset.
    Used in CoreText to implement optical sizing.

    <note>Note: There are 72 points in an inch.</note>
    """
    ...

def font_set_scale(font: font_t, x_scale: int, y_scale: int) -> object:
    """
    Sets the horizontal and vertical scale of a font.
    """
    ...

def font_set_user_data(font: font_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified font object.
    """
    ...

def font_set_var_coords_design(font: font_t, coords: object, coords_length: int) -> object:
    """
    Applies a list of variation coordinates (in design-space units)
    to a font.
    """
    ...

def font_set_var_coords_normalized(font: font_t, coords: object, coords_length: int) -> object:
    """
    Applies a list of variation coordinates (in normalized units)
    to a font.

    <note>Note: Coordinates should be normalized to 2.14.</note>
    """
    ...

def font_set_var_named_instance(font: font_t, instance_index: int) -> object:
    """
    Sets design coords of a font from a named instance index.
    """
    ...

def font_set_variations(font: font_t, variations: object, variations_length: int) -> object:
    """
    Applies a list of font-variation settings to a font.
    """
    ...

def font_subtract_glyph_origin_for_direction(font: font_t, glyph: codepoint_t, direction: direction_t, x: position_t, y: position_t) -> object:
    """
    Subtracts the origin coordinates from an (X,Y) point coordinate,
    in the specified glyph ID in the specified font.

    Calls the appropriate direction-specific variant (horizontal
    or vertical) depending on the value of @direction.
    """
    ...

def ft_face_create(ft_face: FT_Face, destroy: destroy_func_t) -> face_t:
    """
    Creates an #hb_face_t face object from the specified FT_Face.

    This variant of the function does not provide any life-cycle management.

    Most client programs should use hb_ft_face_create_referenced()
    (or, perhaps, hb_ft_face_create_cached()) instead.

    If you know you have valid reasons not to use hb_ft_face_create_referenced(),
    then it is the client program's responsibility to destroy @ft_face
    after the #hb_face_t face object has been destroyed.
    """
    ...

def ft_face_create_cached(ft_face: FT_Face) -> face_t:
    """
    Creates an #hb_face_t face object from the specified FT_Face.

    This variant of the function caches the newly created #hb_face_t
    face object, using the @generic pointer of @ft_face. Subsequent function
    calls that are passed the same @ft_face parameter will have the same
    #hb_face_t returned to them, and that #hb_face_t will be correctly
    reference counted.

    However, client programs are still responsible for destroying
    @ft_face after the last #hb_face_t face object has been destroyed.
    """
    ...

def ft_face_create_referenced(ft_face: FT_Face) -> face_t:
    """
    Creates an #hb_face_t face object from the specified FT_Face.

    This is the preferred variant of the hb_ft_face_create*
    function family, because it calls FT_Reference_Face() on @ft_face,
    ensuring that @ft_face remains alive as long as the resulting
    #hb_face_t face object remains alive. Also calls FT_Done_Face()
    when the #hb_face_t face object is destroyed.

    Use this version unless you know you have good reasons not to.
    """
    ...

def ft_font_changed(font: font_t) -> object:
    ...

def ft_font_create(ft_face: FT_Face, destroy: destroy_func_t) -> font_t:
    """
    Creates an #hb_font_t font object from the specified FT_Face.

    <note>Note: You must set the face size on @ft_face before calling
    hb_ft_font_create() on it. Otherwise, HarfBuzz will not pick up
    the face size.</note>

    This variant of the function does not provide any life-cycle management.

    Most client programs should use hb_ft_font_create_referenced()
    instead.

    If you know you have valid reasons not to use hb_ft_font_create_referenced(),
    then it is the client program's responsibility to destroy @ft_face
    after the #hb_font_t font object has been destroyed.

    HarfBuzz will use the @destroy callback on the #hb_font_t font object
    if it is supplied when you use this function. However, even if @destroy
    is provided, it is the client program's responsibility to destroy @ft_face,
    and it is the client program's responsibility to ensure that @ft_face is
    destroyed only after the #hb_font_t font object has been destroyed.
    """
    ...

def ft_font_create_referenced(ft_face: FT_Face) -> font_t:
    """
    Creates an #hb_font_t font object from the specified FT_Face.

    <note>Note: You must set the face size on @ft_face before calling
    hb_ft_font_create_references() on it. Otherwise, HarfBuzz will not pick up
    the face size.</note>

    This is the preferred variant of the hb_ft_font_create*
    function family, because it calls FT_Reference_Face() on @ft_face,
    ensuring that @ft_face remains alive as long as the resulting
    #hb_font_t font object remains alive.

    Use this version unless you know you have good reasons not to.
    """
    ...

def ft_font_get_face(font: font_t) -> FT_Face:
    ...

def ft_font_get_load_flags(font: font_t) -> int:
    """
    Fetches the FT_Load_Glyph load flags of the specified #hb_font_t.

    For more information, see
    https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#ft_load_xxx
    """
    ...

def ft_font_lock_face(font: font_t) -> FT_Face:
    ...

def ft_font_set_funcs(font: font_t) -> object:
    """
    Configures the font-functions structure of the specified
    #hb_font_t font object to use FreeType font functions.

    In particular, you can use this function to configure an
    existing #hb_face_t face object for use with FreeType font
    functions even if that #hb_face_t face object was initially
    created with hb_face_create(), and therefore was not
    initially configured to use FreeType font functions.

    An #hb_face_t face object created with hb_ft_face_create()
    is preconfigured for FreeType font functions and does not
    require this function to be used.

    <note>Note: Internally, this function creates an FT_Face.
    </note>
    """
    ...

def ft_font_set_load_flags(font: font_t, load_flags: int) -> object:
    """
    Sets the FT_Load_Glyph load flags for the specified #hb_font_t.

    For more information, see
    https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#ft_load_xxx
    """
    ...

def ft_font_unlock_face(font: font_t) -> object:
    ...

def glib_blob_create(gbytes: GLib.Bytes) -> blob_t:
    """
    Creates an #hb_blob_t blob from the specified
    GBytes data structure.
    """
    ...

def glib_get_unicode_funcs() -> unicode_funcs_t:
    """
    Fetches a Unicode-functions structure that is populated
    with the appropriate GLib function for each method.
    """
    ...

def glib_script_from_script(script: script_t) -> GLib.UnicodeScript:
    """
    Fetches the GUnicodeScript identifier that corresponds to the
    specified #hb_script_t script.
    """
    ...

def glib_script_to_script(script: GLib.UnicodeScript) -> script_t:
    """
    Fetches the #hb_script_t script that corresponds to the
    specified GUnicodeScript identifier.
    """
    ...

def glyph_info_get_glyph_flags(info: glyph_info_t) -> glyph_flags_t:
    """
    Returns glyph flags encoded within a #hb_glyph_info_t.
    """
    ...

def graphite2_face_get_gr_face(face: face_t) -> gr_face:
    """
    Fetches the Graphite2 gr_face corresponding to the specified
    #hb_face_t face object.
    """
    ...

def graphite2_font_get_gr_font(font: font_t) -> gr_font:
    ...

def language_from_string(str: object, len: int) -> language_t:
    """
    Converts @str representing a BCP 47 language tag to the corresponding
    #hb_language_t.
    """
    ...

def language_get_default() -> language_t:
    """
    Fetch the default language from current locale.

    <note>Note that the first time this function is called, it calls
    "setlocale (LC_CTYPE, nullptr)" to fetch current locale.  The underlying
    setlocale function is, in many implementations, NOT threadsafe.  To avoid
    problems, call this function once before multiple threads can call it.
    This function is only used from hb_buffer_guess_segment_properties() by
    HarfBuzz itself.</note>
    """
    ...

def language_to_string(language: language_t) -> str:
    """
    Converts an #hb_language_t to a string.
    """
    ...

def map_allocation_successful(map: map_t) -> bool_t:
    """
    Tests whether memory allocation for a set was successful.
    """
    ...

def map_clear(map: map_t) -> object:
    """
    Clears out the contents of @map.
    """
    ...

def map_create() -> map_t:
    """
    Creates a new, initially empty map.
    """
    ...

def map_del(map: map_t, key: codepoint_t) -> object:
    """
    Removes @key and its stored value from @map.
    """
    ...

def map_destroy(map: map_t) -> object:
    """
    Decreases the reference count on a map. When
    the reference count reaches zero, the map is
    destroyed, freeing all memory.
    """
    ...

def map_get(map: map_t, key: codepoint_t) -> codepoint_t:
    """
    Fetches the value stored for @key in @map.
    """
    ...

def map_get_empty() -> map_t:
    """
    Fetches the singleton empty #hb_map_t.
    """
    ...

def map_get_population(map: map_t) -> int:
    """
    Returns the number of key-value pairs in the map.
    """
    ...

def map_get_user_data(map: map_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified map.
    """
    ...

def map_has(map: map_t, key: codepoint_t) -> bool_t:
    """
    Tests whether @key is an element of @map.
    """
    ...

def map_is_empty(map: map_t) -> bool_t:
    """
    Tests whether @map is empty (contains no elements).
    """
    ...

def map_reference(map: map_t) -> map_t:
    """
    Increases the reference count on a map.
    """
    ...

def map_set(map: map_t, key: codepoint_t, value: codepoint_t) -> object:
    """
    Stores @key:@value in the map.
    """
    ...

def map_set_user_data(map: map_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified map.
    """
    ...

def ot_color_glyph_get_layers(face: face_t, glyph: codepoint_t, start_offset: int, layer_count: int, layers: _T.Optional[object]) -> int:
    """
    Fetches a list of all color layers for the specified glyph index in the specified
    face. The list returned will begin at the offset provided.
    """
    ...

def ot_color_glyph_reference_png(font: font_t, glyph: codepoint_t) -> blob_t:
    """
    Fetches the PNG image for a glyph. This function takes a font object, not a face object,
    as input. To get an optimally sized PNG blob, the UPEM value must be set on the @font
    object. If UPEM is unset, the blob returned will be the largest PNG available.
    """
    ...

def ot_color_glyph_reference_svg(face: face_t, glyph: codepoint_t) -> blob_t:
    """
    Fetches the SVG document for a glyph. The blob may be either plain text or gzip-encoded.
    """
    ...

def ot_color_has_layers(face: face_t) -> bool_t:
    """
    Tests whether a face includes any `COLR` color layers.
    """
    ...

def ot_color_has_palettes(face: face_t) -> bool_t:
    """
    Tests whether a face includes a `CPAL` color-palette table.
    """
    ...

def ot_color_has_png(face: face_t) -> bool_t:
    """
    Tests whether a face has PNG glyph images (either in `CBDT` or `sbix` tables).
    """
    ...

def ot_color_has_svg(face: face_t) -> bool_t:
    """
    Tests whether a face includes any `SVG` glyph images.
    """
    ...

def ot_color_palette_color_get_name_id(face: face_t, color_index: int) -> ot_name_id_t:
    """
    Fetches the `name` table Name ID that provides display names for
    the specificed color in a face's `CPAL` color palette.

    Display names can be generic (e.g., "Background") or specific
    (e.g., "Eye color").
    """
    ...

def ot_color_palette_get_colors(face: face_t, palette_index: int, start_offset: int, color_count: int, colors: _T.Optional[object]) -> int:
    """
    Fetches a list of the colors in a color palette.

    After calling this function, @colors will be filled with the palette
    colors. If @colors is NULL, the function will just return the number
    of total colors without storing any actual colors; this can be used
    for allocating a buffer of suitable size before calling
    hb_ot_color_palette_get_colors() a second time.
    """
    ...

def ot_color_palette_get_count(face: face_t) -> int:
    """
    Fetches the number of color palettes in a face.
    """
    ...

def ot_color_palette_get_flags(face: face_t, palette_index: int) -> ot_color_palette_flags_t:
    """
    Fetches the flags defined for a color palette.
    """
    ...

def ot_color_palette_get_name_id(face: face_t, palette_index: int) -> ot_name_id_t:
    """
    Fetches the `name` table Name ID that provides display names for
    a `CPAL` color palette.

    Palette display names can be generic (e.g., "Default") or provide
    specific, themed names (e.g., "Spring", "Summer", "Fall", and "Winter").
    """
    ...

def ot_font_set_funcs(font: font_t) -> object:
    """
    Sets the font functions to use when working with @font.
    """
    ...

def ot_layout_collect_features(face: face_t, table_tag: tag_t, scripts: tag_t, languages: tag_t, features: tag_t, feature_indexes: set_t) -> object:
    """
    Fetches a list of all feature indexes in the specified face's GSUB table
    or GPOS table, underneath the specified scripts, languages, and features.
    If no list of scripts is provided, all scripts will be queried. If no list
    of languages is provided, all languages will be queried. If no list of
    features is provided, all features will be queried.
    """
    ...

def ot_layout_collect_lookups(face: face_t, table_tag: tag_t, scripts: tag_t, languages: tag_t, features: tag_t, lookup_indexes: set_t) -> object:
    """
    Fetches a list of all feature-lookup indexes in the specified face's GSUB
    table or GPOS table, underneath the specified scripts, languages, and
    features. If no list of scripts is provided, all scripts will be queried.
    If no list of languages is provided, all languages will be queried. If no
    list of features is provided, all features will be queried.
    """
    ...

def ot_layout_feature_get_characters(face: face_t, table_tag: tag_t, feature_index: int, start_offset: int, char_count: _T.Optional[int], characters: object) -> int:
    """
    Fetches a list of the characters defined as having a variant under the specified
    "Character Variant" ("cvXX") feature tag.
    """
    ...

def ot_layout_feature_get_lookups(face: face_t, table_tag: tag_t, feature_index: int, start_offset: int, lookup_count: _T.Optional[int], lookup_indexes: object) -> int:
    """
    Fetches a list of all lookups enumerated for the specified feature, in
    the specified face's GSUB table or GPOS table. The list returned will
    begin at the offset provided.
    """
    ...

def ot_layout_feature_get_name_ids(face: face_t, table_tag: tag_t, feature_index: int, label_id: ot_name_id_t, tooltip_id: ot_name_id_t, sample_id: ot_name_id_t, num_named_parameters: int, first_param_id: ot_name_id_t) -> bool_t:
    """
    Fetches name indices from feature parameters for "Stylistic Set" ('ssXX') or
    "Character Variant" ('cvXX') features.
    """
    ...

def ot_layout_feature_with_variations_get_lookups(face: face_t, table_tag: tag_t, feature_index: int, variations_index: int, start_offset: int, lookup_count: _T.Optional[int], lookup_indexes: object) -> int:
    """
    Fetches a list of all lookups enumerated for the specified feature, in
    the specified face's GSUB table or GPOS table, enabled at the specified
    variations index. The list returned will begin at the offset provided.
    """
    ...

def ot_layout_get_attach_points(face: face_t, glyph: codepoint_t, start_offset: int, point_count: _T.Optional[int], point_array: object) -> int:
    """
    Fetches a list of all attachment points for the specified glyph in the GDEF
    table of the face. The list returned will begin at the offset provided.

    Useful if the client program wishes to cache the list.
    """
    ...

def ot_layout_get_baseline(font: font_t, baseline_tag: ot_layout_baseline_tag_t, direction: direction_t, script_tag: tag_t, language_tag: tag_t, coord: position_t) -> bool_t:
    """
    Fetches a baseline value from the face.
    """
    ...

def ot_layout_get_glyph_class(face: face_t, glyph: codepoint_t) -> ot_layout_glyph_class_t:
    """
    Fetches the GDEF class of the requested glyph in the specified face.
    """
    ...

def ot_layout_get_glyphs_in_class(face: face_t, klass: ot_layout_glyph_class_t, glyphs: set_t) -> object:
    """
    Retrieves the set of all glyphs from the face that belong to the requested
    glyph class in the face's GDEF table.
    """
    ...

def ot_layout_get_ligature_carets(font: font_t, direction: direction_t, glyph: codepoint_t, start_offset: int, caret_count: _T.Optional[int], caret_array: object) -> int:
    """
    Fetches a list of the caret positions defined for a ligature glyph in the GDEF
    table of the font. The list returned will begin at the offset provided.
    """
    ...

def ot_layout_get_size_params(face: face_t, design_size: int, subfamily_id: int, subfamily_name_id: ot_name_id_t, range_start: int, range_end: int) -> bool_t:
    """
    Fetches optical-size feature data (i.e., the `size` feature from GPOS). Note that
    the subfamily_id and the subfamily name string (accessible via the subfamily_name_id)
    as used here are defined as pertaining only to fonts within a font family that differ
    specifically in their respective size ranges; other ways to differentiate fonts within
    a subfamily are not covered by the `size` feature.

    For more information on this distinction, see the [`size` feature documentation](
    https://docs.microsoft.com/en-us/typography/opentype/spec/features_pt#tag-size).
    """
    ...

def ot_layout_has_glyph_classes(face: face_t) -> bool_t:
    """
    Tests whether a face has any glyph classes defined in its GDEF table.
    """
    ...

def ot_layout_has_positioning(face: face_t) -> bool_t:
    ...

def ot_layout_has_substitution(face: face_t) -> bool_t:
    """
    Tests whether the specified face includes any GSUB substitutions.
    """
    ...

def ot_layout_language_find_feature(face: face_t, table_tag: tag_t, script_index: int, language_index: int, feature_tag: tag_t, feature_index: int) -> bool_t:
    """
    Fetches the index of a given feature tag in the specified face's GSUB table
    or GPOS table, underneath the specified script and language.
    """
    ...

def ot_layout_language_get_feature_indexes(face: face_t, table_tag: tag_t, script_index: int, language_index: int, start_offset: int, feature_count: _T.Optional[int], feature_indexes: object) -> int:
    """
    Fetches a list of all features in the specified face's GSUB table
    or GPOS table, underneath the specified script and language. The list
    returned will begin at the offset provided.
    """
    ...

def ot_layout_language_get_feature_tags(face: face_t, table_tag: tag_t, script_index: int, language_index: int, start_offset: int, feature_count: _T.Optional[int], feature_tags: object) -> int:
    """
    Fetches a list of all features in the specified face's GSUB table
    or GPOS table, underneath the specified script and language. The list
    returned will begin at the offset provided.
    """
    ...

def ot_layout_language_get_required_feature(face: face_t, table_tag: tag_t, script_index: int, language_index: int, feature_index: int, feature_tag: tag_t) -> bool_t:
    """
    Fetches the tag of a requested feature index in the given face's GSUB or GPOS table,
    underneath the specified script and language.
    """
    ...

def ot_layout_language_get_required_feature_index(face: face_t, table_tag: tag_t, script_index: int, language_index: int, feature_index: int) -> bool_t:
    """
    Fetches the index of a requested feature in the given face's GSUB or GPOS table,
    underneath the specified script and language.
    """
    ...

def ot_layout_lookup_collect_glyphs(face: face_t, table_tag: tag_t, lookup_index: int, glyphs_before: set_t, glyphs_input: set_t, glyphs_after: set_t, glyphs_output: set_t) -> object:
    """
    Fetches a list of all glyphs affected by the specified lookup in the
    specified face's GSUB table or GPOS table.
    """
    ...

def ot_layout_lookup_get_glyph_alternates(face: face_t, lookup_index: int, glyph: codepoint_t, start_offset: int, alternate_count: _T.Optional[int], alternate_glyphs: object) -> int:
    """
    Fetches alternates of a glyph from a given GSUB lookup index.
    """
    ...

def ot_layout_lookup_substitute_closure(face: face_t, lookup_index: int, glyphs: set_t) -> object:
    """
    Compute the transitive closure of glyphs needed for a
    specified lookup.
    """
    ...

def ot_layout_lookup_would_substitute(face: face_t, lookup_index: int, glyphs: codepoint_t, glyphs_length: int, zero_context: bool_t) -> bool_t:
    """
    Tests whether a specified lookup in the specified face would
    trigger a substitution on the given glyph sequence.
    """
    ...

def ot_layout_lookups_substitute_closure(face: face_t, lookups: set_t, glyphs: set_t) -> object:
    """
    Compute the transitive closure of glyphs needed for all of the
    provided lookups.
    """
    ...

def ot_layout_script_find_language(face: face_t, table_tag: tag_t, script_index: int, language_tag: tag_t, language_index: int) -> bool_t:
    """
    Fetches the index of a given language tag in the specified face's GSUB table
    or GPOS table, underneath the specified script tag.
    """
    ...

def ot_layout_script_get_language_tags(face: face_t, table_tag: tag_t, script_index: int, start_offset: int, language_count: _T.Optional[int], language_tags: object) -> int:
    """
    Fetches a list of language tags in the given face's GSUB or GPOS table, underneath
    the specified script index. The list returned will begin at the offset provided.
    """
    ...

def ot_layout_script_select_language(face: face_t, table_tag: tag_t, script_index: int, language_count: int, language_tags: tag_t, language_index: int) -> bool_t:
    """
    Fetches the index of a given language tag in the specified face's GSUB table
    or GPOS table, underneath the specified script index.
    """
    ...

def ot_layout_table_choose_script(face: face_t, table_tag: tag_t, script_tags: tag_t, script_index: int, chosen_script: tag_t) -> bool_t:
    """
    Deprecated since 2.0.0
    """
    ...

def ot_layout_table_find_feature_variations(face: face_t, table_tag: tag_t, coords: int, num_coords: int, variations_index: int) -> bool_t:
    """
    Fetches a list of feature variations in the specified face's GSUB table
    or GPOS table, at the specified variation coordinates.
    """
    ...

def ot_layout_table_find_script(face: face_t, table_tag: tag_t, script_tag: tag_t, script_index: int) -> bool_t:
    """
    Fetches the index if a given script tag in the specified face's GSUB table
    or GPOS table.
    """
    ...

def ot_layout_table_get_feature_tags(face: face_t, table_tag: tag_t, start_offset: int, feature_count: _T.Optional[int], feature_tags: object) -> int:
    """
    Fetches a list of all feature tags in the given face's GSUB or GPOS table.
    """
    ...

def ot_layout_table_get_lookup_count(face: face_t, table_tag: tag_t) -> int:
    """
    Fetches the total number of lookups enumerated in the specified
    face's GSUB table or GPOS table.
    """
    ...

def ot_layout_table_get_script_tags(face: face_t, table_tag: tag_t, start_offset: int, script_count: _T.Optional[int], script_tags: object) -> int:
    """
    Fetches a list of all scripts enumerated in the specified face's GSUB table
    or GPOS table. The list returned will begin at the offset provided.
    """
    ...

def ot_layout_table_select_script(face: face_t, table_tag: tag_t, script_count: int, script_tags: tag_t, script_index: int, chosen_script: tag_t) -> bool_t:
    ...

def ot_math_get_constant(font: font_t, constant: ot_math_constant_t) -> position_t:
    """
    Fetches the specified math constant. For most constants, the value returned
    is an #hb_position_t.

    However, if the requested constant is #HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN,
    #HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN or
    #HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN, then the return value is
    an integer between 0 and 100 representing that percentage.
    """
    ...

def ot_math_get_glyph_assembly(font: font_t, glyph: codepoint_t, direction: direction_t, start_offset: int, parts_count: int, parts: object, italics_correction: position_t) -> int:
    """
    Fetches the GlyphAssembly for the specified font, glyph index, and direction.
    Returned are a list of #hb_ot_math_glyph_part_t glyph parts that can be
    used to draw the glyph and an italics-correction value (if one is defined
    in the font).

    <note>The @direction parameter is only used to select between horizontal
    or vertical directions for the construction. Even though all #hb_direction_t
    values are accepted, only the result of #HB_DIRECTION_IS_HORIZONTAL is
    considered.</note>
    """
    ...

def ot_math_get_glyph_italics_correction(font: font_t, glyph: codepoint_t) -> position_t:
    """
    Fetches an italics-correction value (if one exists) for the specified
    glyph index.
    """
    ...

def ot_math_get_glyph_kerning(font: font_t, glyph: codepoint_t, kern: ot_math_kern_t, correction_height: position_t) -> position_t:
    """
    Fetches the math kerning (cut-ins) value for the specified font, glyph index, and
    @kern.

    If the MathKern table is found, the function examines it to find a height
    value that is greater or equal to @correction_height. If such a height
    value is found, corresponding kerning value from the table is returned. If
    no such height value is found, the last kerning value is returned.
    """
    ...

def ot_math_get_glyph_top_accent_attachment(font: font_t, glyph: codepoint_t) -> position_t:
    """
    Fetches a top-accent-attachment value (if one exists) for the specified
    glyph index.

    For any glyph that does not have a top-accent-attachment value - that is,
    a glyph not covered by the `MathTopAccentAttachment` table (or, when
    @font has no `MathTopAccentAttachment` table or no `MATH` table, any
    glyph) - the function synthesizes a value, returning the position at
    one-half the glyph's advance width.
    """
    ...

def ot_math_get_glyph_variants(font: font_t, glyph: codepoint_t, direction: direction_t, start_offset: int, variants_count: int, variants: object) -> int:
    """
    Fetches the MathGlyphConstruction for the specified font, glyph index, and
    direction. The corresponding list of size variants is returned as a list of
    #hb_ot_math_glyph_variant_t structs.

    <note>The @direction parameter is only used to select between horizontal
    or vertical directions for the construction. Even though all #hb_direction_t
    values are accepted, only the result of #HB_DIRECTION_IS_HORIZONTAL is
    considered.</note>
    """
    ...

def ot_math_get_min_connector_overlap(font: font_t, direction: direction_t) -> position_t:
    """
    Fetches the MathVariants table for the specified font and returns the
    minimum overlap of connecting glyphs that are required to draw a glyph
    assembly in the specified direction.

    <note>The @direction parameter is only used to select between horizontal
    or vertical directions for the construction. Even though all #hb_direction_t
    values are accepted, only the result of #HB_DIRECTION_IS_HORIZONTAL is
    considered.</note>
    """
    ...

def ot_math_has_data(face: face_t) -> bool_t:
    """
    Tests whether a face has a `MATH` table.
    """
    ...

def ot_math_is_glyph_extended_shape(face: face_t, glyph: codepoint_t) -> bool_t:
    """
    Tests whether the given glyph index is an extended shape in the face.
    """
    ...

def ot_meta_get_entry_tags(face: face_t, start_offset: int, entries_count: _T.Optional[int], entries: object) -> int:
    ...

def ot_meta_reference_entry(face: face_t, meta_tag: ot_meta_tag_t) -> blob_t:
    """
    It fetches metadata entry of a given tag from a font.
    """
    ...

def ot_metrics_get_position(font: font_t, metrics_tag: ot_metrics_tag_t, position: position_t) -> bool_t:
    """
    It fetches metrics value corresponding to a given tag from a font.
    """
    ...

def ot_metrics_get_variation(font: font_t, metrics_tag: ot_metrics_tag_t) -> float:
    ...

def ot_metrics_get_x_variation(font: font_t, metrics_tag: ot_metrics_tag_t) -> position_t:
    ...

def ot_metrics_get_y_variation(font: font_t, metrics_tag: ot_metrics_tag_t) -> position_t:
    ...

def ot_name_get_utf16(face: face_t, name_id: ot_name_id_t, language: language_t, text_size: _T.Optional[int], text: object) -> int:
    """
    Fetches a font name from the OpenType 'name' table.
    If @language is #HB_LANGUAGE_INVALID, English ("en") is assumed.
    Returns string in UTF-16 encoding.
    """
    ...

def ot_name_get_utf32(face: face_t, name_id: ot_name_id_t, language: language_t, text_size: _T.Optional[int], text: object) -> int:
    """
    Fetches a font name from the OpenType 'name' table.
    If @language is #HB_LANGUAGE_INVALID, English ("en") is assumed.
    Returns string in UTF-32 encoding.
    """
    ...

def ot_name_get_utf8(face: face_t, name_id: ot_name_id_t, language: language_t, text_size: _T.Optional[int], text: object) -> int:
    """
    Fetches a font name from the OpenType 'name' table.
    If @language is #HB_LANGUAGE_INVALID, English ("en") is assumed.
    Returns string in UTF-8 encoding.
    """
    ...

def ot_name_list_names(face: face_t, num_entries: int) -> object:
    """
    Enumerates all available name IDs and language combinations. Returned
    array is owned by the @face and should not be modified.  It can be
    used as long as @face is alive.
    """
    ...

def ot_shape_glyphs_closure(font: font_t, buffer: buffer_t, features: object, num_features: int, glyphs: set_t) -> object:
    """
    Computes the transitive closure of glyphs needed for a specified
    input buffer under the given font and feature list. The closure is
    computed as a set, not as a list.
    """
    ...

def ot_tag_from_language(language: language_t) -> tag_t:
    ...

def ot_tag_to_language(tag: tag_t) -> language_t:
    ...

def ot_tag_to_script(tag: tag_t) -> script_t:
    ...

def ot_tags_from_script(script: script_t, script_tag_1: tag_t, script_tag_2: tag_t) -> object:
    ...

def ot_tags_from_script_and_language(script: script_t, language: language_t, script_count: _T.Optional[int], script_tags: tag_t, language_count: _T.Optional[int], language_tags: tag_t) -> object:
    """
    Converts an #hb_script_t and an #hb_language_t to script and language tags.
    """
    ...

def ot_tags_to_script_and_language(script_tag: tag_t, language_tag: tag_t, script: _T.Optional[script_t], language: _T.Optional[language_t]) -> object:
    """
    Converts a script tag and a language tag to an #hb_script_t and an
    #hb_language_t.
    """
    ...

def ot_var_find_axis(face: face_t, axis_tag: tag_t, axis_index: int, axis_info: ot_var_axis_t) -> bool_t:
    """
    Fetches the variation-axis information corresponding to the specified axis tag
    in the specified face.
    """
    ...

def ot_var_find_axis_info(face: face_t, axis_tag: tag_t, axis_info: ot_var_axis_info_t) -> bool_t:
    """
    Fetches the variation-axis information corresponding to the specified axis tag
    in the specified face.
    """
    ...

def ot_var_get_axes(face: face_t, start_offset: int, axes_count: _T.Optional[int], axes_array: object) -> int:
    """
    Fetches a list of all variation axes in the specified face. The list returned will begin
    at the offset provided.
    """
    ...

def ot_var_get_axis_count(face: face_t) -> int:
    """
    Fetches the number of OpenType variation axes included in the face.
    """
    ...

def ot_var_get_axis_infos(face: face_t, start_offset: int, axes_count: _T.Optional[int], axes_array: object) -> int:
    """
    Fetches a list of all variation axes in the specified face. The list returned will begin
    at the offset provided.
    """
    ...

def ot_var_get_named_instance_count(face: face_t) -> int:
    """
    Fetches the number of named instances included in the face.
    """
    ...

def ot_var_has_data(face: face_t) -> bool_t:
    """
    Tests whether a face includes any OpenType variation data in the `fvar` table.
    """
    ...

def ot_var_named_instance_get_design_coords(face: face_t, instance_index: int, coords_length: _T.Optional[int], coords: object) -> int:
    """
    Fetches the design-space coordinates corresponding to the given
    named instance in the face.
    """
    ...

def ot_var_named_instance_get_postscript_name_id(face: face_t, instance_index: int) -> ot_name_id_t:
    """
    Fetches the `name` table Name ID that provides display names for
    the "PostScript name" defined for the given named instance in the face.
    """
    ...

def ot_var_named_instance_get_subfamily_name_id(face: face_t, instance_index: int) -> ot_name_id_t:
    """
    Fetches the `name` table Name ID that provides display names for
    the "Subfamily name" defined for the given named instance in the face.
    """
    ...

def ot_var_normalize_coords(face: face_t, coords_length: int, design_coords: float, normalized_coords: int) -> object:
    """
    Normalizes the given design-space coordinates. The minimum and maximum
    values for the axis are mapped to the interval [-1,1], with the default
    axis value mapped to 0.

    Any additional scaling defined in the face's `avar` table is also
    applied, as described at https://docs.microsoft.com/en-us/typography/opentype/spec/avar
    """
    ...

def ot_var_normalize_variations(face: face_t, variations: variation_t, variations_length: int, coords: object, coords_length: int) -> object:
    """
    Normalizes all of the coordinates in the given list of variation axes.
    """
    ...

def script_from_iso15924_tag(tag: tag_t) -> script_t:
    """
    Converts an ISO 15924 script tag to a corresponding #hb_script_t.
    """
    ...

def script_from_string(str: object, len: int) -> script_t:
    """
    Converts a string @str representing an ISO 15924 script tag to a
    corresponding #hb_script_t. Shorthand for hb_tag_from_string() then
    hb_script_from_iso15924_tag().
    """
    ...

def script_get_horizontal_direction(script: script_t) -> direction_t:
    """
    Fetches the #hb_direction_t of a script when it is
    set horizontally. All right-to-left scripts will return
    #HB_DIRECTION_RTL. All left-to-right scripts will return
    #HB_DIRECTION_LTR.  Scripts that can be written either
    horizontally or vertically will return #HB_DIRECTION_INVALID.
    Unknown scripts will return #HB_DIRECTION_LTR.
    """
    ...

def script_to_iso15924_tag(script: script_t) -> tag_t:
    """
    Converts an #hb_script_t to a corresponding ISO 15924 script tag.
    """
    ...

def segment_properties_equal(a: segment_properties_t, b: segment_properties_t) -> bool_t:
    """
    Checks the equality of two #hb_segment_properties_t's.
    """
    ...

def segment_properties_hash(p: segment_properties_t) -> int:
    """
    Creates a hash representing @p.
    """
    ...

def set_add(set: set_t, codepoint: codepoint_t) -> object:
    """
    Adds @codepoint to @set.
    """
    ...

def set_add_range(set: set_t, first: codepoint_t, last: codepoint_t) -> object:
    """
    Adds all of the elements from @first to @last
    (inclusive) to @set.
    """
    ...

def set_allocation_successful(set: set_t) -> bool_t:
    """
    Tests whether memory allocation for a set was successful.
    """
    ...

def set_clear(set: set_t) -> object:
    """
    Clears out the contents of a set.
    """
    ...

def set_create() -> set_t:
    """
    Creates a new, initially empty set.
    """
    ...

def set_del(set: set_t, codepoint: codepoint_t) -> object:
    """
    Removes @codepoint from @set.
    """
    ...

def set_del_range(set: set_t, first: codepoint_t, last: codepoint_t) -> object:
    """
    Removes all of the elements from @first to @last
    (inclusive) from @set.
    """
    ...

def set_destroy(set: set_t) -> object:
    """
    Decreases the reference count on a set. When
    the reference count reaches zero, the set is
    destroyed, freeing all memory.
    """
    ...

def set_get_empty() -> set_t:
    """
    Fetches the singleton empty #hb_set_t.
    """
    ...

def set_get_max(set: set_t) -> codepoint_t:
    """
    Finds the largest element in the set.
    """
    ...

def set_get_min(set: set_t) -> codepoint_t:
    """
    Finds the smallest element in the set.
    """
    ...

def set_get_population(set: set_t) -> int:
    """
    Returns the number of elements in the set.
    """
    ...

def set_get_user_data(set: set_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified set.
    """
    ...

def set_has(set: set_t, codepoint: codepoint_t) -> bool_t:
    """
    Tests whether @codepoint belongs to @set.
    """
    ...

def set_intersect(set: set_t, other: set_t) -> object:
    """
    Makes @set the intersection of @set and @other.
    """
    ...

def set_invert(set: set_t) -> object:
    """
    Inverts the contents of @set.
    """
    ...

def set_is_empty(set: set_t) -> bool_t:
    """
    Tests whether a set is empty (contains no elements).
    """
    ...

def set_is_equal(set: set_t, other: set_t) -> bool_t:
    """
    Tests whether @set and @other are equal (contain the same
    elements).
    """
    ...

def set_is_subset(set: set_t, larger_set: set_t) -> bool_t:
    """
    Tests whether @set is a subset of @larger_set.
    """
    ...

def set_next(set: set_t, codepoint: codepoint_t) -> bool_t:
    """
    Fetches the next element in @set that is greater than current value of @codepoint.

    Set @codepoint to %HB_SET_VALUE_INVALID to get started.
    """
    ...

def set_next_range(set: set_t, first: codepoint_t, last: codepoint_t) -> bool_t:
    """
    Fetches the next consecutive range of elements in @set that
    are greater than current value of @last.

    Set @last to %HB_SET_VALUE_INVALID to get started.
    """
    ...

def set_previous(set: set_t, codepoint: codepoint_t) -> bool_t:
    """
    Fetches the previous element in @set that is lower than current value of @codepoint.

    Set @codepoint to %HB_SET_VALUE_INVALID to get started.
    """
    ...

def set_previous_range(set: set_t, first: codepoint_t, last: codepoint_t) -> bool_t:
    """
    Fetches the previous consecutive range of elements in @set that
    are greater than current value of @last.

    Set @first to %HB_SET_VALUE_INVALID to get started.
    """
    ...

def set_reference(set: set_t) -> set_t:
    """
    Increases the reference count on a set.
    """
    ...

def set_set(set: set_t, other: set_t) -> object:
    """
    Makes the contents of @set equal to the contents of @other.
    """
    ...

def set_set_user_data(set: set_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified set.
    """
    ...

def set_subtract(set: set_t, other: set_t) -> object:
    """
    Subtracts the contents of @other from @set.
    """
    ...

def set_symmetric_difference(set: set_t, other: set_t) -> object:
    """
    Makes @set the symmetric difference of @set
    and @other.
    """
    ...

def set_union(set: set_t, other: set_t) -> object:
    """
    Makes @set the union of @set and @other.
    """
    ...

def shape(font: font_t, buffer: buffer_t, features: _T.Optional[object], num_features: int) -> object:
    """
    Shapes @buffer using @font turning its Unicode characters content to
    positioned glyphs. If @features is not %NULL, it will be used to control the
    features applied during shaping. If two @features have the same tag but
    overlapping ranges the value of the feature with the higher index takes
    precedence.
    """
    ...

def shape_full(font: font_t, buffer: buffer_t, features: _T.Optional[object], num_features: int, shaper_list: _T.Optional[object]) -> bool_t:
    """
    See hb_shape() for details. If @shaper_list is not %NULL, the specified
    shapers will be used in the given order, otherwise the default shapers list
    will be used.
    """
    ...

def shape_list_shapers() -> object:
    """
    Retrieves the list of shapers supported by HarfBuzz.
    """
    ...

def shape_plan_create(face: face_t, props: segment_properties_t, user_features: object, num_user_features: int, shaper_list: object) -> shape_plan_t:
    """
    Constructs a shaping plan for a combination of @face, @user_features, @props,
    and @shaper_list.
    """
    ...

def shape_plan_create2(face: face_t, props: segment_properties_t, user_features: object, num_user_features: int, coords: object, num_coords: int, shaper_list: object) -> shape_plan_t:
    """
    The variable-font version of #hb_shape_plan_create.
    Constructs a shaping plan for a combination of @face, @user_features, @props,
    and @shaper_list, plus the variation-space coordinates @coords.
    """
    ...

def shape_plan_create_cached(face: face_t, props: segment_properties_t, user_features: object, num_user_features: int, shaper_list: object) -> shape_plan_t:
    """
    Creates a cached shaping plan suitable for reuse, for a combination
    of @face, @user_features, @props, and @shaper_list.
    """
    ...

def shape_plan_create_cached2(face: face_t, props: segment_properties_t, user_features: object, num_user_features: int, coords: object, num_coords: int, shaper_list: object) -> shape_plan_t:
    """
    The variable-font version of #hb_shape_plan_create_cached.
    Creates a cached shaping plan suitable for reuse, for a combination
    of @face, @user_features, @props, and @shaper_list, plus the
    variation-space coordinates @coords.
    """
    ...

def shape_plan_destroy(shape_plan: shape_plan_t) -> object:
    """
    Decreases the reference count on the given shaping plan. When the
    reference count reaches zero, the shaping plan is destroyed,
    freeing all memory.
    """
    ...

def shape_plan_execute(shape_plan: shape_plan_t, font: font_t, buffer: buffer_t, features: object, num_features: int) -> bool_t:
    """
    Executes the given shaping plan on the specified buffer, using
    the given @font and @features.
    """
    ...

def shape_plan_get_empty() -> shape_plan_t:
    """
    Fetches the singleton empty shaping plan.
    """
    ...

def shape_plan_get_shaper(shape_plan: shape_plan_t) -> str:
    """
    Fetches the shaper from a given shaping plan.
    """
    ...

def shape_plan_get_user_data(shape_plan: shape_plan_t, key: user_data_key_t) -> object:
    """
    Fetches the user data associated with the specified key,
    attached to the specified shaping plan.
    """
    ...

def shape_plan_reference(shape_plan: shape_plan_t) -> shape_plan_t:
    """
    Increases the reference count on the given shaping plan.
    """
    ...

def shape_plan_set_user_data(shape_plan: shape_plan_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the given shaping plan.
    """
    ...

def tag_from_string(str: object, len: int) -> tag_t:
    """
    Converts a string into an #hb_tag_t. Valid tags
    are four characters. Shorter input strings will be
    padded with spaces. Longer input strings will be
    truncated.
    """
    ...

def tag_to_string(tag: tag_t, buf: object) -> object:
    """
    Converts an #hb_tag_t to a string and returns it in @buf.
    Strings will be four characters long.
    """
    ...

def unicode_combining_class(ufuncs: unicode_funcs_t, unicode: codepoint_t) -> unicode_combining_class_t:
    """
    Retrieves the Canonical Combining Class (ccc) property
    of code point @unicode.
    """
    ...

def unicode_compose(ufuncs: unicode_funcs_t, a: codepoint_t, b: codepoint_t, ab: codepoint_t) -> bool_t:
    """
    Composes the code point sequence @a,@b by canonical equivalence into
    code point @ab.
    """
    ...

def unicode_decompose(ufuncs: unicode_funcs_t, ab: codepoint_t, a: codepoint_t, b: codepoint_t) -> bool_t:
    """
    Decomposes code point @ab by canonical equivalence, into code points
    @a and @b.
    """
    ...

def unicode_decompose_compatibility(ufuncs: unicode_funcs_t, u: codepoint_t, decomposed: codepoint_t) -> int:
    """
    Fetches the compatibility decomposition of a Unicode
    code point. Deprecated.
    """
    ...

def unicode_eastasian_width(ufuncs: unicode_funcs_t, unicode: codepoint_t) -> int:
    ...

def unicode_funcs_create(parent: _T.Optional[unicode_funcs_t]) -> unicode_funcs_t:
    """
    Creates a new #hb_unicode_funcs_t structure of Unicode functions.
    """
    ...

def unicode_funcs_destroy(ufuncs: unicode_funcs_t) -> object:
    """
    Decreases the reference count on a Unicode-functions structure. When
    the reference count reaches zero, the Unicode-functions structure is
    destroyed, freeing all memory.
    """
    ...

def unicode_funcs_get_default() -> unicode_funcs_t:
    """
    Fetches a pointer to the default Unicode-functions structure that is used
    when no functions are explicitly set on #hb_buffer_t.
    """
    ...

def unicode_funcs_get_empty() -> unicode_funcs_t:
    """
    Fetches the singleton empty Unicode-functions structure.
    """
    ...

def unicode_funcs_get_parent(ufuncs: unicode_funcs_t) -> unicode_funcs_t:
    """
    Fetches the parent of the Unicode-functions structure
    @ufuncs.
    """
    ...

def unicode_funcs_get_user_data(ufuncs: unicode_funcs_t, key: user_data_key_t) -> object:
    """
    Fetches the user-data associated with the specified key,
    attached to the specified Unicode-functions structure.
    """
    ...

def unicode_funcs_is_immutable(ufuncs: unicode_funcs_t) -> bool_t:
    """
    Tests whether the specified Unicode-functions structure
    is immutable.
    """
    ...

def unicode_funcs_make_immutable(ufuncs: unicode_funcs_t) -> object:
    """
    Makes the specified Unicode-functions structure
    immutable.
    """
    ...

def unicode_funcs_reference(ufuncs: unicode_funcs_t) -> unicode_funcs_t:
    """
    Increases the reference count on a Unicode-functions structure.
    """
    ...

def unicode_funcs_set_combining_class_func(ufuncs: unicode_funcs_t, func: unicode_combining_class_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_unicode_combining_class_func_t.
    """
    ...

def unicode_funcs_set_compose_func(ufuncs: unicode_funcs_t, func: unicode_compose_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_unicode_compose_func_t.
    """
    ...

def unicode_funcs_set_decompose_compatibility_func(ufuncs: unicode_funcs_t, func: unicode_decompose_compatibility_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    ...

def unicode_funcs_set_decompose_func(ufuncs: unicode_funcs_t, func: unicode_decompose_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_unicode_decompose_func_t.
    """
    ...

def unicode_funcs_set_eastasian_width_func(ufuncs: unicode_funcs_t, func: unicode_eastasian_width_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    ...

def unicode_funcs_set_general_category_func(ufuncs: unicode_funcs_t, func: unicode_general_category_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_unicode_general_category_func_t.
    """
    ...

def unicode_funcs_set_mirroring_func(ufuncs: unicode_funcs_t, func: unicode_mirroring_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_unicode_mirroring_func_t.
    """
    ...

def unicode_funcs_set_script_func(ufuncs: unicode_funcs_t, func: unicode_script_func_t, user_data: _T.Optional[object], destroy: destroy_func_t) -> object:
    """
    Sets the implementation function for #hb_unicode_script_func_t.
    """
    ...

def unicode_funcs_set_user_data(ufuncs: unicode_funcs_t, key: user_data_key_t, data: _T.Optional[object], destroy: destroy_func_t, replace: bool_t) -> bool_t:
    """
    Attaches a user-data key/data pair to the specified Unicode-functions structure.
    """
    ...

def unicode_general_category(ufuncs: unicode_funcs_t, unicode: codepoint_t) -> unicode_general_category_t:
    """
    Retrieves the General Category (gc) property
    of code point @unicode.
    """
    ...

def unicode_mirroring(ufuncs: unicode_funcs_t, unicode: codepoint_t) -> codepoint_t:
    """
    Retrieves the Bi-directional Mirroring Glyph code
    point defined for code point @unicode.
    """
    ...

def unicode_script(ufuncs: unicode_funcs_t, unicode: codepoint_t) -> script_t:
    """
    Retrieves the #hb_script_t script to which code
    point @unicode belongs.
    """
    ...

def variation_from_string(str: str, len: int, variation: variation_t) -> bool_t:
    ...

def variation_to_string(variation: variation_t, buf: str, size: int) -> object:
    ...

def version(major: int, minor: int, micro: int) -> object:
    """
    Returns library version as three integer components.
    """
    ...

def version_atleast(major: int, minor: int, micro: int) -> bool_t:
    """
    Tests the library version against a minimum value,
    as three integer components.
    """
    ...

def version_string() -> str:
    """
    Returns library version as a string with three components.
    """
    ...


