"""
Stub file for GdkPixbuf. Autogenerated with gi-stubgen.
"""

import typing as _T  # noqa
from enum import Enum

from gi.repository import GLib, GModule, GObject, Gio

PIXBUF_MAJOR = 2
"""
Major version of gdk-pixbuf library, that is the "0" in
"0.8.2" for example.
"""

PIXBUF_MICRO = 8
"""
Micro version of gdk-pixbuf library, that is the "2" in
"0.8.2" for example.
"""

PIXBUF_MINOR = 42
"""
Minor version of gdk-pixbuf library, that is the "8" in
"0.8.2" for example.
"""

PIXBUF_VERSION = "2.42.8"
"""
Contains the full version of GdkPixbuf as a string.

This is the version being compiled against; contrast with
`gdk_pixbuf_version`.
"""


class Colorspace(Enum):
    """
    This enumeration defines the color spaces that are supported by
    the gdk-pixbuf library.

    Currently only RGB is supported.
    """
    RGB = 0

class InterpType(Enum):
    """
    Interpolation modes for scaling functions.

    The `GDK_INTERP_NEAREST` mode is the fastest scaling method, but has
    horrible quality when scaling down; `GDK_INTERP_BILINEAR` is the best
    choice if you aren't sure what to choose, it has a good speed/quality
    balance.

    **Note**: Cubic filtering is missing from the list; hyperbolic
    interpolation is just as fast and results in higher quality.
    """
    NEAREST = 0
    TILES = 1
    BILINEAR = 2
    HYPER = 3

class PixbufAlphaMode(Enum):
    """
    Control the alpha channel for drawables.

    These values can be passed to gdk_pixbuf_xlib_render_to_drawable_alpha()
    in gdk-pixbuf-xlib to control how the alpha channel of an image should
    be handled.

    This function can create a bilevel clipping mask (black and white) and use
    it while painting the image.

    In the future, when the X Window System gets an alpha channel extension,
    it will be possible to do full alpha compositing onto arbitrary drawables.
    For now both cases fall back to a bilevel clipping mask.
    """
    BILEVEL = 0
    FULL = 1

class PixbufRotation(Enum):
    """
    The possible rotations which can be passed to gdk_pixbuf_rotate_simple().

    To make them easier to use, their numerical values are the actual degrees.
    """
    NONE = 0
    COUNTERCLOCKWISE = 90
    UPSIDEDOWN = 180
    CLOCKWISE = 270

class PixbufFormatFlags(Enum):
    """
    Flags which allow a module to specify further details about the supported
    operations.
    """
    WRITABLE = 1
    SCALABLE = 2
    THREADSAFE = 4


class Pixbuf(GObject.Object, Gio.Icon, Gio.LoadableIcon):
    """
    A pixel buffer.

    `GdkPixbuf` contains information about an image's pixel data,
    its color space, bits per sample, width and height, and the
    rowstride (the number of bytes between the start of one row
    and the start of the next).

    ## Creating new `GdkPixbuf`

    The most basic way to create a pixbuf is to wrap an existing pixel
    buffer with a [class@GdkPixbuf.Pixbuf] instance. You can use the
    [`ctor@GdkPixbuf.Pixbuf.new_from_data`] function to do this.

    Every time you create a new `GdkPixbuf` instance for some data, you
    will need to specify the destroy notification function that will be
    called when the data buffer needs to be freed; this will happen when
    a `GdkPixbuf` is finalized by the reference counting functions. If
    you have a chunk of static data compiled into your application, you
    can pass in `NULL` as the destroy notification function so that the
    data will not be freed.

    The [`ctor@GdkPixbuf.Pixbuf.new`] constructor function can be used
    as a convenience to create a pixbuf with an empty buffer; this is
    equivalent to allocating a data buffer using `malloc()` and then
    wrapping it with `gdk_pixbuf_new_from_data()`. The `gdk_pixbuf_new()`
    function will compute an optimal rowstride so that rendering can be
    performed with an efficient algorithm.

    As a special case, you can use the [`ctor@GdkPixbuf.Pixbuf.new_from_xpm_data`]
    function to create a pixbuf from inline XPM image data.

    You can also copy an existing pixbuf with the [method@Pixbuf.copy]
    function. This is not the same as just acquiring a reference to
    the old pixbuf instance: the copy function will actually duplicate
    the pixel data in memory and create a new [class@Pixbuf] instance
    for it.

    ## Reference counting

    `GdkPixbuf` structures are reference counted. This means that an
    application can share a single pixbuf among many parts of the
    code. When a piece of the program needs to use a pixbuf, it should
    acquire a reference to it by calling `g_object_ref()`; when it no
    longer needs the pixbuf, it should release the reference it acquired
    by calling `g_object_unref()`. The resources associated with a
    `GdkPixbuf` will be freed when its reference count drops to zero.
    Newly-created `GdkPixbuf` instances start with a reference count
    of one.

    ## Image Data

    Image data in a pixbuf is stored in memory in an uncompressed,
    packed format. Rows in the image are stored top to bottom, and
    in each row pixels are stored from left to right.

    There may be padding at the end of a row.

    The "rowstride" value of a pixbuf, as returned by [`method@GdkPixbuf.Pixbuf.get_rowstride`],
    indicates the number of bytes between rows.

    **NOTE**: If you are copying raw pixbuf data with `memcpy()` note that the
    last row in the pixbuf may not be as wide as the full rowstride, but rather
    just as wide as the pixel data needs to be; that is: it is unsafe to do
    `memcpy (dest, pixels, rowstride * height)` to copy a whole pixbuf. Use
    [method@GdkPixbuf.Pixbuf.copy] instead, or compute the width in bytes of the
    last row as:

    ```c
    last_row = width * ((n_channels * bits_per_sample + 7) / 8);
    ```

    The same rule applies when iterating over each row of a `GdkPixbuf` pixels
    array.

    The following code illustrates a simple `put_pixel()`
    function for RGB pixbufs with 8 bits per channel with an alpha
    channel.

    ```c
    static void
    put_pixel (GdkPixbuf *pixbuf,
               int x,
    	   int y,
    	   guchar red,
    	   guchar green,
    	   guchar blue,
    	   guchar alpha)
    {
      int n_channels = gdk_pixbuf_get_n_channels (pixbuf);

      // Ensure that the pixbuf is valid
      g_assert (gdk_pixbuf_get_colorspace (pixbuf) == GDK_COLORSPACE_RGB);
      g_assert (gdk_pixbuf_get_bits_per_sample (pixbuf) == 8);
      g_assert (gdk_pixbuf_get_has_alpha (pixbuf));
      g_assert (n_channels == 4);

      int width = gdk_pixbuf_get_width (pixbuf);
      int height = gdk_pixbuf_get_height (pixbuf);

      // Ensure that the coordinates are in a valid range
      g_assert (x >= 0 && x < width);
      g_assert (y >= 0 && y < height);

      int rowstride = gdk_pixbuf_get_rowstride (pixbuf);

      // The pixel buffer in the GdkPixbuf instance
      guchar *pixels = gdk_pixbuf_get_pixels (pixbuf);

      // The pixel we wish to modify
      guchar *p = pixels + y * rowstride + x * n_channels;
      p[0] = red;
      p[1] = green;
      p[2] = blue;
      p[3] = alpha;
    }
    ```

    ## Loading images

    The `GdkPixBuf` class provides a simple mechanism for loading
    an image from a file in synchronous and asynchronous fashion.

    For GUI applications, it is recommended to use the asynchronous
    stream API to avoid blocking the control flow of the application.

    Additionally, `GdkPixbuf` provides the [class@GdkPixbuf.PixbufLoader`]
    API for progressive image loading.

    ## Saving images

    The `GdkPixbuf` class provides methods for saving image data in
    a number of file formats. The formatted data can be written to a
    file or to a memory buffer. `GdkPixbuf` can also call a user-defined
    callback on the data, which allows to e.g. write the image
    to a socket or store it in a database.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls, colorspace: Colorspace, has_alpha: bool, bits_per_sample: int, width: int, height: int) -> Pixbuf:
        """
        Creates a new `GdkPixbuf` structure and allocates a buffer for it.

        If the allocation of the buffer failed, this function will return `NULL`.

        The buffer has an optimal rowstride. Note that the buffer is not cleared;
        you will have to fill it completely yourself.
        """
        ...


    @classmethod
    def new_from_bytes(cls, data: GLib.Bytes, colorspace: Colorspace, has_alpha: bool, bits_per_sample: int, width: int, height: int, rowstride: int) -> Pixbuf:
        """
        Creates a new #GdkPixbuf out of in-memory readonly image data.

        Currently only RGB images with 8 bits per sample are supported.

        This is the `GBytes` variant of gdk_pixbuf_new_from_data(), useful
        for language bindings.
        """
        ...


    @classmethod
    def new_from_data(cls, data: object, colorspace: Colorspace, has_alpha: bool, bits_per_sample: int, width: int, height: int, rowstride: int, destroy_fn: _T.Optional[PixbufDestroyNotify], destroy_fn_data: _T.Optional[object]) -> Pixbuf:
        """
        Creates a new #GdkPixbuf out of in-memory image data.

        Currently only RGB images with 8 bits per sample are supported.

        Since you are providing a pre-allocated pixel buffer, you must also
        specify a way to free that data.  This is done with a function of
        type `GdkPixbufDestroyNotify`.  When a pixbuf created with is
        finalized, your destroy notification function will be called, and
        it is its responsibility to free the pixel array.

        See also: [ctor@GdkPixbuf.Pixbuf.new_from_bytes]
        """
        ...


    @classmethod
    def new_from_file(cls, filename: str) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from a file.

        The file format is detected automatically.

        If `NULL` is returned, then @error will be set. Possible errors are:

         - the file could not be opened
         - there is no loader for the file's format
         - there is not enough memory to allocate the image buffer
         - the image buffer contains invalid data

        The error domains are `GDK_PIXBUF_ERROR` and `G_FILE_ERROR`.
        """
        ...


    @classmethod
    def new_from_file_at_scale(cls, filename: str, width: int, height: int, preserve_aspect_ratio: bool) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from a file.

        The file format is detected automatically.

        If `NULL` is returned, then @error will be set. Possible errors are:

         - the file could not be opened
         - there is no loader for the file's format
         - there is not enough memory to allocate the image buffer
         - the image buffer contains invalid data

        The error domains are `GDK_PIXBUF_ERROR` and `G_FILE_ERROR`.

        The image will be scaled to fit in the requested size, optionally preserving
        the image's aspect ratio.

        When preserving the aspect ratio, a `width` of -1 will cause the image
        to be scaled to the exact given height, and a `height` of -1 will cause
        the image to be scaled to the exact given width. When not preserving
        aspect ratio, a `width` or `height` of -1 means to not scale the image
        at all in that dimension. Negative values for `width` and `height` are
        allowed since 2.8.
        """
        ...


    @classmethod
    def new_from_file_at_size(cls, filename: str, width: int, height: int) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from a file.

        The file format is detected automatically.

        If `NULL` is returned, then @error will be set. Possible errors are:

         - the file could not be opened
         - there is no loader for the file's format
         - there is not enough memory to allocate the image buffer
         - the image buffer contains invalid data

        The error domains are `GDK_PIXBUF_ERROR` and `G_FILE_ERROR`.

        The image will be scaled to fit in the requested size, preserving
        the image's aspect ratio. Note that the returned pixbuf may be smaller
        than `width` x `height`, if the aspect ratio requires it. To load
        and image at the requested size, regardless of aspect ratio, use
        [ctor@GdkPixbuf.Pixbuf.new_from_file_at_scale].
        """
        ...


    @classmethod
    def new_from_inline(cls, data_length: int, data: object, copy_pixels: bool) -> Pixbuf:
        """
        Creates a `GdkPixbuf` from a flat representation that is suitable for
        storing as inline data in a program.

        This is useful if you want to ship a program with images, but don't want
        to depend on any external files.

        GdkPixbuf ships with a program called `gdk-pixbuf-csource`, which allows
        for conversion of `GdkPixbuf`s into such a inline representation.

        In almost all cases, you should pass the `--raw` option to
        `gdk-pixbuf-csource`. A sample invocation would be:

        ```
        gdk-pixbuf-csource --raw --name=myimage_inline myimage.png
        ```

        For the typical case where the inline pixbuf is read-only static data,
        you don't need to copy the pixel data unless you intend to write to
        it, so you can pass `FALSE` for `copy_pixels`. If you pass `--rle` to
        `gdk-pixbuf-csource`, a copy will be made even if `copy_pixels` is `FALSE`,
        so using this option is generally a bad idea.

        If you create a pixbuf from const inline data compiled into your
        program, it's probably safe to ignore errors and disable length checks,
        since things will always succeed:

        ```c
        pixbuf = gdk_pixbuf_new_from_inline (-1, myimage_inline, FALSE, NULL);
        ```

        For non-const inline data, you could get out of memory. For untrusted
        inline data located at runtime, you could have corrupt inline data in
        addition.
        """
        ...


    @classmethod
    def new_from_resource(cls, resource_path: str) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from an resource.

        The file format is detected automatically. If `NULL` is returned, then
        @error will be set.
        """
        ...


    @classmethod
    def new_from_resource_at_scale(cls, resource_path: str, width: int, height: int, preserve_aspect_ratio: bool) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from an resource.

        The file format is detected automatically. If `NULL` is returned, then
        @error will be set.

        The image will be scaled to fit in the requested size, optionally
        preserving the image's aspect ratio. When preserving the aspect ratio,
        a @width of -1 will cause the image to be scaled to the exact given
        height, and a @height of -1 will cause the image to be scaled to the
        exact given width. When not preserving aspect ratio, a @width or
        @height of -1 means to not scale the image at all in that dimension.

        The stream is not closed.
        """
        ...


    @classmethod
    def new_from_stream(cls, stream: Gio.InputStream, cancellable: _T.Optional[Gio.Cancellable]) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from an input stream.

        The file format is detected automatically.

        If `NULL` is returned, then `error` will be set.

        The `cancellable` can be used to abort the operation from another thread.
        If the operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        returned. Other possible errors are in the `GDK_PIXBUF_ERROR` and
        `G_IO_ERROR` domains.

        The stream is not closed.
        """
        ...


    @classmethod
    def new_from_stream_at_scale(cls, stream: Gio.InputStream, width: int, height: int, preserve_aspect_ratio: bool, cancellable: _T.Optional[Gio.Cancellable]) -> Pixbuf:
        """
        Creates a new pixbuf by loading an image from an input stream.

        The file format is detected automatically. If `NULL` is returned, then
        @error will be set. The @cancellable can be used to abort the operation
        from another thread. If the operation was cancelled, the error
        `G_IO_ERROR_CANCELLED` will be returned. Other possible errors are in
        the `GDK_PIXBUF_ERROR` and `G_IO_ERROR` domains.

        The image will be scaled to fit in the requested size, optionally
        preserving the image's aspect ratio.

        When preserving the aspect ratio, a `width` of -1 will cause the image to be
        scaled to the exact given height, and a `height` of -1 will cause the image
        to be scaled to the exact given width. If both `width` and `height` are
        given, this function will behave as if the smaller of the two values
        is passed as -1.

        When not preserving aspect ratio, a `width` or `height` of -1 means to not
        scale the image at all in that dimension.

        The stream is not closed.
        """
        ...


    @classmethod
    def new_from_stream_finish(cls, async_result: Gio.AsyncResult) -> Pixbuf:
        """
        Finishes an asynchronous pixbuf creation operation started with
        gdk_pixbuf_new_from_stream_async().
        """
        ...


    @classmethod
    def new_from_xpm_data(cls, data: object) -> Pixbuf:
        """
        Creates a new pixbuf by parsing XPM data in memory.

        This data is commonly the result of including an XPM file into a
        program's C source.
        """
        ...

    def add_alpha(self, substitute_color: bool, r: int, g: int, b: int) -> Pixbuf:
        """
        Takes an existing pixbuf and adds an alpha channel to it.

        If the existing pixbuf already had an alpha channel, the channel
        values are copied from the original; otherwise, the alpha channel
        is initialized to 255 (full opacity).

        If `substitute_color` is `TRUE`, then the color specified by the
        (`r`, `g`, `b`) arguments will be assigned zero opacity. That is,
        if you pass `(255, 255, 255)` for the substitute color, all white
        pixels will become fully transparent.

        If `substitute_color` is `FALSE`, then the (`r`, `g`, `b`) arguments
        will be ignored.
        """
        ...

    def apply_embedded_orientation(self) -> Pixbuf:
        """
        Takes an existing pixbuf and checks for the presence of an
        associated "orientation" option.

        The orientation option may be provided by the JPEG loader (which
        reads the exif orientation tag) or the TIFF loader (which reads
        the TIFF orientation tag, and compensates it for the partial
        transforms performed by libtiff).

        If an orientation option/tag is present, the appropriate transform
        will be performed so that the pixbuf is oriented correctly.
        """
        ...

    def composite(self, dest: Pixbuf, dest_x: int, dest_y: int, dest_width: int, dest_height: int, offset_x: float, offset_y: float, scale_x: float, scale_y: float, interp_type: InterpType, overall_alpha: int) -> object:
        """
        Creates a transformation of the source image @src by scaling by
        @scale_x and @scale_y then translating by @offset_x and @offset_y.

        This gives an image in the coordinates of the destination pixbuf.
        The rectangle (@dest_x, @dest_y, @dest_width, @dest_height)
        is then alpha blended onto the corresponding rectangle of the
        original destination image.

        When the destination rectangle contains parts not in the source
        image, the data at the edges of the source image is replicated
        to infinity.

        ![](composite.png)
        """
        ...

    def composite_color(self, dest: Pixbuf, dest_x: int, dest_y: int, dest_width: int, dest_height: int, offset_x: float, offset_y: float, scale_x: float, scale_y: float, interp_type: InterpType, overall_alpha: int, check_x: int, check_y: int, check_size: int, color1: int, color2: int) -> object:
        """
        Creates a transformation of the source image @src by scaling by
        @scale_x and @scale_y then translating by @offset_x and @offset_y,
        then alpha blends the rectangle (@dest_x ,@dest_y, @dest_width,
        @dest_height) of the resulting image with a checkboard of the
        colors @color1 and @color2 and renders it onto the destination
        image.

        If the source image has no alpha channel, and @overall_alpha is 255, a fast
        path is used which omits the alpha blending and just performs the scaling.

        See gdk_pixbuf_composite_color_simple() for a simpler variant of this
        function suitable for many tasks.
        """
        ...

    def composite_color_simple(self, dest_width: int, dest_height: int, interp_type: InterpType, overall_alpha: int, check_size: int, color1: int, color2: int) -> Pixbuf:
        """
        Creates a new pixbuf by scaling `src` to `dest_width` x `dest_height`
        and alpha blending the result with a checkboard of colors `color1`
        and `color2`.
        """
        ...

    def copy(self) -> Pixbuf:
        """
        Creates a new `GdkPixbuf` with a copy of the information in the specified
        `pixbuf`.

        Note that this does not copy the options set on the original `GdkPixbuf`,
        use gdk_pixbuf_copy_options() for this.
        """
        ...

    def copy_area(self, src_x: int, src_y: int, width: int, height: int, dest_pixbuf: Pixbuf, dest_x: int, dest_y: int) -> object:
        """
        Copies a rectangular area from `src_pixbuf` to `dest_pixbuf`.

        Conversion of pixbuf formats is done automatically.

        If the source rectangle overlaps the destination rectangle on the
        same pixbuf, it will be overwritten during the copy operation.
        Therefore, you can not use this function to scroll a pixbuf.
        """
        ...

    def copy_options(self, dest_pixbuf: Pixbuf) -> bool:
        """
        Copies the key/value pair options attached to a `GdkPixbuf` to another
        `GdkPixbuf`.

        This is useful to keep original metadata after having manipulated
        a file. However be careful to remove metadata which you've already
        applied, such as the "orientation" option after rotating the image.
        """
        ...

    def fill(self, pixel: int) -> object:
        """
        Clears a pixbuf to the given RGBA value, converting the RGBA value into
        the pixbuf's pixel format.

        The alpha component will be ignored if the pixbuf doesn't have an alpha
        channel.
        """
        ...

    def flip(self, horizontal: bool) -> Pixbuf:
        """
        Flips a pixbuf horizontally or vertically and returns the
        result in a new pixbuf.
        """
        ...

    def get_bits_per_sample(self) -> int:
        """
        Queries the number of bits per color sample in a pixbuf.
        """
        ...

    def get_byte_length(self) -> int:
        """
        Returns the length of the pixel data, in bytes.
        """
        ...

    def get_colorspace(self) -> Colorspace:
        """
        Queries the color space of a pixbuf.
        """
        ...

    def get_has_alpha(self) -> bool:
        """
        Queries whether a pixbuf has an alpha channel (opacity information).
        """
        ...

    def get_height(self) -> int:
        """
        Queries the height of a pixbuf.
        """
        ...

    def get_n_channels(self) -> int:
        """
        Queries the number of channels of a pixbuf.
        """
        ...

    def get_option(self, key: str) -> str:
        """
        Looks up @key in the list of options that may have been attached to the
        @pixbuf when it was loaded, or that may have been attached by another
        function using gdk_pixbuf_set_option().

        For instance, the ANI loader provides "Title" and "Artist" options.
        The ICO, XBM, and XPM loaders provide "x_hot" and "y_hot" hot-spot
        options for cursor definitions. The PNG loader provides the tEXt ancillary
        chunk key/value pairs as options. Since 2.12, the TIFF and JPEG loaders
        return an "orientation" option string that corresponds to the embedded
        TIFF/Exif orientation tag (if present). Since 2.32, the TIFF loader sets
        the "multipage" option string to "yes" when a multi-page TIFF is loaded.
        Since 2.32 the JPEG and PNG loaders set "x-dpi" and "y-dpi" if the file
        contains image density information in dots per inch.
        Since 2.36.6, the JPEG loader sets the "comment" option with the comment
        EXIF tag.
        """
        ...

    def get_options(self) -> GLib.HashTable:
        """
        Returns a `GHashTable` with a list of all the options that may have been
        attached to the `pixbuf` when it was loaded, or that may have been
        attached by another function using [method@GdkPixbuf.Pixbuf.set_option].
        """
        ...

    def get_pixels(self) -> object:
        """
        Queries a pointer to the pixel data of a pixbuf.

        This function will cause an implicit copy of the pixbuf data if the
        pixbuf was created from read-only data.

        Please see the section on [image data](class.Pixbuf.html#image-data) for information
        about how the pixel data is stored in memory.
        """
        ...

    def get_pixels_with_length(self, length: int) -> object:
        """
        Queries a pointer to the pixel data of a pixbuf.

        This function will cause an implicit copy of the pixbuf data if the
        pixbuf was created from read-only data.

        Please see the section on [image data](class.Pixbuf.html#image-data) for information
        about how the pixel data is stored in memory.
        """
        ...

    def get_rowstride(self) -> int:
        """
        Queries the rowstride of a pixbuf, which is the number of bytes between
        the start of a row and the start of the next row.
        """
        ...

    def get_width(self) -> int:
        """
        Queries the width of a pixbuf.
        """
        ...

    def new_subpixbuf(self, src_x: int, src_y: int, width: int, height: int) -> Pixbuf:
        """
        Creates a new pixbuf which represents a sub-region of `src_pixbuf`.

        The new pixbuf shares its pixels with the original pixbuf, so
        writing to one affects both.  The new pixbuf holds a reference to
        `src_pixbuf`, so `src_pixbuf` will not be finalized until the new
        pixbuf is finalized.

        Note that if `src_pixbuf` is read-only, this function will force it
        to be mutable.
        """
        ...

    def read_pixel_bytes(self) -> GLib.Bytes:
        """
        Provides a #GBytes buffer containing the raw pixel data; the data
        must not be modified.

        This function allows skipping the implicit copy that must be made
        if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
        """
        ...

    def read_pixels(self) -> int:
        """
        Provides a read-only pointer to the raw pixel data.

        This function allows skipping the implicit copy that must be made
        if gdk_pixbuf_get_pixels() is called on a read-only pixbuf.
        """
        ...

    def ref(self) -> Pixbuf:
        """
        Adds a reference to a pixbuf.
        """
        ...

    def remove_option(self, key: str) -> bool:
        """
        Removes the key/value pair option attached to a `GdkPixbuf`.
        """
        ...

    def rotate_simple(self, angle: PixbufRotation) -> Pixbuf:
        """
        Rotates a pixbuf by a multiple of 90 degrees, and returns the
        result in a new pixbuf.

        If `angle` is 0, this function will return a copy of `src`.
        """
        ...

    def saturate_and_pixelate(self, dest: Pixbuf, saturation: float, pixelate: bool) -> object:
        """
        Modifies saturation and optionally pixelates `src`, placing the result in
        `dest`.

        The `src` and `dest` pixbufs must have the same image format, size, and
        rowstride.

        The `src` and `dest` arguments may be the same pixbuf with no ill effects.

        If `saturation` is 1.0 then saturation is not changed. If it's less than 1.0,
        saturation is reduced (the image turns toward grayscale); if greater than
        1.0, saturation is increased (the image gets more vivid colors).

        If `pixelate` is `TRUE`, then pixels are faded in a checkerboard pattern to
        create a pixelated image.
        """
        ...

    def save(self, filename: str, type: str, error: _T.Optional[GLib.Error], *args: object) -> bool:
        """
        Saves pixbuf to a file in format @type. By default, "jpeg", "png", "ico"
        and "bmp" are possible file formats to save in, but more formats may be
        installed. The list of all writable formats can be determined in the
        following way:

        ```c
        void add_if_writable (GdkPixbufFormat *data, GSList **list)
        {
          if (gdk_pixbuf_format_is_writable (data))
            *list = g_slist_prepend (*list, data);
        }

        GSList *formats = gdk_pixbuf_get_formats ();
        GSList *writable_formats = NULL;
        g_slist_foreach (formats, add_if_writable, &writable_formats);
        g_slist_free (formats);
        ```

        If `error` is set, `FALSE` will be returned. Possible errors include
        those in the `GDK_PIXBUF_ERROR` domain and those in the `G_FILE_ERROR`
        domain.

        The variable argument list should be `NULL`-terminated; if not empty,
        it should contain pairs of strings that modify the save
        parameters. For example:

        ```c
        gdk_pixbuf_save (pixbuf, handle, "jpeg", &error, "quality", "100", NULL);
        ```

        Currently only few parameters exist.

        JPEG images can be saved with a "quality" parameter; its value should be
        in the range `[0, 100]`. JPEG and PNG density can be set by setting the
        "x-dpi" and "y-dpi" parameters to the appropriate values in dots per inch.

        Text chunks can be attached to PNG images by specifying parameters of
        the form "tEXt::key", where key is an ASCII string of length 1-79.
        The values are UTF-8 encoded strings. The PNG compression level can
        be specified using the "compression" parameter; it's value is in an
        integer in the range of `[0, 9]`.

        ICC color profiles can also be embedded into PNG, JPEG and TIFF images.
        The "icc-profile" value should be the complete ICC profile encoded
        into base64.

        ```c
        char *contents;
        gsize length;

        // icm_path is set elsewhere
        g_file_get_contents (icm_path, &contents, &length, NULL);

        char *contents_encode = g_base64_encode ((const guchar *) contents, length);

        gdk_pixbuf_save (pixbuf, handle, "png", &error, "icc-profile", contents_encode, NULL);
        ```

        TIFF images recognize:

         1. a "bits-per-sample" option (integer) which can be either 1 for saving
            bi-level CCITTFAX4 images, or 8 for saving 8-bits per sample
         2. a "compression" option (integer) which can be 1 for no compression,
            2 for Huffman, 5 for LZW, 7 for JPEG and 8 for DEFLATE (see the libtiff
            documentation and tiff.h for all supported codec values)
         3. an "icc-profile" option (zero-terminated string) containing a base64
            encoded ICC color profile.

        ICO images can be saved in depth 16, 24, or 32, by using the "depth"
        parameter. When the ICO saver is given "x_hot" and "y_hot" parameters,
        it produces a CUR instead of an ICO.
        """
        ...

    def save_to_buffer(self, buffer: object, buffer_size: int, type: str, error: _T.Optional[GLib.Error], *args: object) -> bool:
        """
        Saves pixbuf to a new buffer in format `type`, which is currently "jpeg",
        "png", "tiff", "ico" or "bmp".

        This is a convenience function that uses `gdk_pixbuf_save_to_callback()`
        to do the real work.

        Note that the buffer is not `NUL`-terminated and may contain embedded `NUL`
        characters.

        If @error is set, `FALSE` will be returned and @buffer will be set to
        `NULL`. Possible errors include those in the `GDK_PIXBUF_ERROR`
        domain.

        See `gdk_pixbuf_save()` for more details.
        """
        ...

    def save_to_bufferv(self, buffer: object, buffer_size: int, type: str, option_keys: _T.Optional[object], option_values: _T.Optional[object]) -> bool:
        """
        Vector version of `gdk_pixbuf_save_to_buffer()`.

        Saves pixbuf to a new buffer in format @type, which is currently "jpeg",
        "tiff", "png", "ico" or "bmp".

        See [method@GdkPixbuf.Pixbuf.save_to_buffer] for more details.
        """
        ...

    def save_to_callback(self, save_func: PixbufSaveFunc, user_data: _T.Optional[object], type: str, error: _T.Optional[GLib.Error], *args: object) -> bool:
        """
        Saves pixbuf in format `type` by feeding the produced data to a
        callback.

        This function can be used when you want to store the image to something
        other than a file, such as an in-memory buffer or a socket.

        If @error is set, `FALSE` will be returned. Possible errors
        include those in the `GDK_PIXBUF_ERROR` domain and whatever the save
        function generates.

        See [method@GdkPixbuf.Pixbuf.save] for more details.
        """
        ...

    def save_to_callbackv(self, save_func: PixbufSaveFunc, user_data: _T.Optional[object], type: str, option_keys: _T.Optional[object], option_values: _T.Optional[object]) -> bool:
        """
        Vector version of `gdk_pixbuf_save_to_callback()`.

        Saves pixbuf to a callback in format @type, which is currently "jpeg",
        "png", "tiff", "ico" or "bmp".

        If @error is set, `FALSE` will be returned.

        See [method@GdkPixbuf.Pixbuf.save_to_callback] for more details.
        """
        ...

    def save_to_stream(self, stream: Gio.OutputStream, type: str, cancellable: _T.Optional[Gio.Cancellable], error: _T.Optional[GLib.Error], *args: object) -> bool:
        """
        Saves `pixbuf` to an output stream.

        Supported file formats are currently "jpeg", "tiff", "png", "ico" or
        "bmp". See `gdk_pixbuf_save_to_buffer()` for more details.

        The `cancellable` can be used to abort the operation from another
        thread. If the operation was cancelled, the error `G_IO_ERROR_CANCELLED`
        will be returned. Other possible errors are in the `GDK_PIXBUF_ERROR`
        and `G_IO_ERROR` domains.

        The stream is not closed at the end of this call.
        """
        ...

    def save_to_stream_async(self, stream: Gio.OutputStream, type: str, cancellable: _T.Optional[Gio.Cancellable], callback: _T.Optional[Gio.AsyncReadyCallback], user_data: _T.Optional[object], *args: object) -> object:
        """
        Saves `pixbuf` to an output stream asynchronously.

        For more details see gdk_pixbuf_save_to_stream(), which is the synchronous
        version of this function.

        When the operation is finished, `callback` will be called in the main thread.

        You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
        the operation.
        """
        ...

    def save_to_streamv(self, stream: Gio.OutputStream, type: str, option_keys: _T.Optional[object], option_values: _T.Optional[object], cancellable: _T.Optional[Gio.Cancellable]) -> bool:
        """
        Saves `pixbuf` to an output stream.

        Supported file formats are currently "jpeg", "tiff", "png", "ico" or
        "bmp".

        See [method@GdkPixbuf.Pixbuf.save_to_stream] for more details.
        """
        ...

    def save_to_streamv_async(self, stream: Gio.OutputStream, type: str, option_keys: _T.Optional[object], option_values: _T.Optional[object], cancellable: _T.Optional[Gio.Cancellable], callback: _T.Optional[Gio.AsyncReadyCallback], user_data: _T.Optional[object]) -> object:
        """
        Saves `pixbuf` to an output stream asynchronously.

        For more details see gdk_pixbuf_save_to_streamv(), which is the synchronous
        version of this function.

        When the operation is finished, `callback` will be called in the main thread.

        You can then call gdk_pixbuf_save_to_stream_finish() to get the result of
        the operation.
        """
        ...

    def savev(self, filename: str, type: str, option_keys: _T.Optional[object], option_values: _T.Optional[object]) -> bool:
        """
        Vector version of `gdk_pixbuf_save()`.

        Saves pixbuf to a file in `type`, which is currently "jpeg", "png", "tiff", "ico" or "bmp".

        If @error is set, `FALSE` will be returned.

        See [method@GdkPixbuf.Pixbuf.save] for more details.
        """
        ...

    def scale(self, dest: Pixbuf, dest_x: int, dest_y: int, dest_width: int, dest_height: int, offset_x: float, offset_y: float, scale_x: float, scale_y: float, interp_type: InterpType) -> object:
        """
        Creates a transformation of the source image @src by scaling by
        @scale_x and @scale_y then translating by @offset_x and @offset_y,
        then renders the rectangle (@dest_x, @dest_y, @dest_width,
        @dest_height) of the resulting image onto the destination image
        replacing the previous contents.

        Try to use gdk_pixbuf_scale_simple() first; this function is
        the industrial-strength power tool you can fall back to, if
        gdk_pixbuf_scale_simple() isn't powerful enough.

        If the source rectangle overlaps the destination rectangle on the
        same pixbuf, it will be overwritten during the scaling which
        results in rendering artifacts.
        """
        ...

    def scale_simple(self, dest_width: int, dest_height: int, interp_type: InterpType) -> Pixbuf:
        """
        Create a new pixbuf containing a copy of `src` scaled to
        `dest_width` x `dest_height`.

        This function leaves `src` unaffected.

        The `interp_type` should be `GDK_INTERP_NEAREST` if you want maximum
        speed (but when scaling down `GDK_INTERP_NEAREST` is usually unusably
        ugly). The default `interp_type` should be `GDK_INTERP_BILINEAR` which
        offers reasonable quality and speed.

        You can scale a sub-portion of `src` by creating a sub-pixbuf
        pointing into `src`; see [method@GdkPixbuf.Pixbuf.new_subpixbuf].

        If `dest_width` and `dest_height` are equal to the width and height of
        `src`, this function will return an unscaled copy of `src`.

        For more complicated scaling/alpha blending see [method@GdkPixbuf.Pixbuf.scale]
        and [method@GdkPixbuf.Pixbuf.composite].
        """
        ...

    def set_option(self, key: str, value: str) -> bool:
        """
        Attaches a key/value pair as an option to a `GdkPixbuf`.

        If `key` already exists in the list of options attached to the `pixbuf`,
        the new value is ignored and `FALSE` is returned.
        """
        ...

    def unref(self) -> object:
        """
        Removes a reference from a pixbuf.
        """
        ...


    ...

class PixbufAnimation(GObject.Object):
    """
    An opaque object representing an animation.

    The GdkPixBuf library provides a simple mechanism to load and
    represent animations. An animation is conceptually a series of
    frames to be displayed over time.

    The animation may not be represented as a series of frames
    internally; for example, it may be stored as a sprite and
    instructions for moving the sprite around a background.

    To display an animation you don't need to understand its
    representation, however; you just ask `GdkPixbuf` what should
    be displayed at a given point in time.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new_from_file(cls, filename: str) -> PixbufAnimation:
        """
        Creates a new animation by loading it from a file.

        The file format is detected automatically.

        If the file's format does not support multi-frame images, then an animation
        with a single frame will be created.

        Possible errors are in the `GDK_PIXBUF_ERROR` and `G_FILE_ERROR` domains.
        """
        ...


    @classmethod
    def new_from_resource(cls, resource_path: str) -> PixbufAnimation:
        """
        Creates a new pixbuf animation by loading an image from an resource.

        The file format is detected automatically. If `NULL` is returned, then
        @error will be set.
        """
        ...


    @classmethod
    def new_from_stream(cls, stream: Gio.InputStream, cancellable: _T.Optional[Gio.Cancellable]) -> PixbufAnimation:
        """
        Creates a new animation by loading it from an input stream.

        The file format is detected automatically.

        If `NULL` is returned, then @error will be set.

        The @cancellable can be used to abort the operation from another thread.
        If the operation was cancelled, the error `G_IO_ERROR_CANCELLED` will be
        returned. Other possible errors are in the `GDK_PIXBUF_ERROR` and
        `G_IO_ERROR` domains.

        The stream is not closed.
        """
        ...


    @classmethod
    def new_from_stream_finish(cls, async_result: Gio.AsyncResult) -> PixbufAnimation:
        """
        Finishes an asynchronous pixbuf animation creation operation started with
        [func@GdkPixbuf.PixbufAnimation.new_from_stream_async].
        """
        ...

    def get_height(self) -> int:
        """
        Queries the height of the bounding box of a pixbuf animation.
        """
        ...

    def get_iter(self, start_time: _T.Optional[GLib.TimeVal]) -> PixbufAnimationIter:
        """
        Get an iterator for displaying an animation.

        The iterator provides the frames that should be displayed at a
        given time.

        @start_time would normally come from g_get_current_time(), and marks
        the beginning of animation playback. After creating an iterator, you
        should immediately display the pixbuf returned by
        gdk_pixbuf_animation_iter_get_pixbuf(). Then, you should install
        a timeout (with g_timeout_add()) or by some other mechanism ensure
        that you'll update the image after
        gdk_pixbuf_animation_iter_get_delay_time() milliseconds. Each time
        the image is updated, you should reinstall the timeout with the new,
        possibly-changed delay time.

        As a shortcut, if @start_time is `NULL`, the result of
        g_get_current_time() will be used automatically.

        To update the image (i.e. possibly change the result of
        gdk_pixbuf_animation_iter_get_pixbuf() to a new frame of the animation),
        call gdk_pixbuf_animation_iter_advance().

        If you're using #GdkPixbufLoader, in addition to updating the image
        after the delay time, you should also update it whenever you
        receive the area_updated signal and
        gdk_pixbuf_animation_iter_on_currently_loading_frame() returns
        `TRUE`. In this case, the frame currently being fed into the loader
        has received new data, so needs to be refreshed. The delay time for
        a frame may also be modified after an area_updated signal, for
        example if the delay time for a frame is encoded in the data after
        the frame itself. So your timeout should be reinstalled after any
        area_updated signal.

        A delay time of -1 is possible, indicating "infinite".
        """
        ...

    def get_static_image(self) -> Pixbuf:
        """
        Retrieves a static image for the animation.

        If an animation is really just a plain image (has only one frame),
        this function returns that image.

        If the animation is an animation, this function returns a reasonable
        image to use as a static unanimated image, which might be the first
        frame, or something more sophisticated depending on the file format.

        If an animation hasn't loaded any frames yet, this function will
        return `NULL`.
        """
        ...

    def get_width(self) -> int:
        """
        Queries the width of the bounding box of a pixbuf animation.
        """
        ...

    def is_static_image(self) -> bool:
        """
        Checks whether the animation is a static image.

        If you load a file with gdk_pixbuf_animation_new_from_file() and it
        turns out to be a plain, unanimated image, then this function will
        return `TRUE`. Use gdk_pixbuf_animation_get_static_image() to retrieve
        the image.
        """
        ...

    def ref(self) -> PixbufAnimation:
        """
        Adds a reference to an animation.
        """
        ...

    def unref(self) -> object:
        """
        Removes a reference from an animation.
        """
        ...


    ...

class PixbufAnimationIter(GObject.Object):
    """
    An opaque object representing an iterator which points to a
    certain position in an animation.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...

    def advance(self, current_time: _T.Optional[GLib.TimeVal]) -> bool:
        """
        Possibly advances an animation to a new frame.

        Chooses the frame based on the start time passed to
        gdk_pixbuf_animation_get_iter().

        @current_time would normally come from g_get_current_time(), and
        must be greater than or equal to the time passed to
        gdk_pixbuf_animation_get_iter(), and must increase or remain
        unchanged each time gdk_pixbuf_animation_iter_get_pixbuf() is
        called. That is, you can't go backward in time; animations only
        play forward.

        As a shortcut, pass `NULL` for the current time and g_get_current_time()
        will be invoked on your behalf. So you only need to explicitly pass
        @current_time if you're doing something odd like playing the animation
        at double speed.

        If this function returns `FALSE`, there's no need to update the animation
        display, assuming the display had been rendered prior to advancing;
        if `TRUE`, you need to call gdk_pixbuf_animation_iter_get_pixbuf()
        and update the display with the new pixbuf.
        """
        ...

    def get_delay_time(self) -> int:
        """
        Gets the number of milliseconds the current pixbuf should be displayed,
        or -1 if the current pixbuf should be displayed forever.

        The `g_timeout_add()` function conveniently takes a timeout in milliseconds,
        so you can use a timeout to schedule the next update.

        Note that some formats, like GIF, might clamp the timeout values in the
        image file to avoid updates that are just too quick. The minimum timeout
        for GIF images is currently 20 milliseconds.
        """
        ...

    def get_pixbuf(self) -> Pixbuf:
        """
        Gets the current pixbuf which should be displayed.

        The pixbuf might not be the same size as the animation itself
        (gdk_pixbuf_animation_get_width(), gdk_pixbuf_animation_get_height()).

        This pixbuf should be displayed for gdk_pixbuf_animation_iter_get_delay_time()
        milliseconds.

        The caller of this function does not own a reference to the returned
        pixbuf; the returned pixbuf will become invalid when the iterator
        advances to the next frame, which may happen anytime you call
        gdk_pixbuf_animation_iter_advance().

        Copy the pixbuf to keep it (don't just add a reference), as it may get
        recycled as you advance the iterator.
        """
        ...

    def on_currently_loading_frame(self) -> bool:
        """
        Used to determine how to respond to the area_updated signal on
        #GdkPixbufLoader when loading an animation.

        The `::area_updated` signal is emitted for an area of the frame currently
        streaming in to the loader. So if you're on the currently loading frame,
        you will need to redraw the screen for the updated area.
        """
        ...


    ...

class PixbufLoader(GObject.Object):
    """
    Incremental image loader.

    `GdkPixbufLoader` provides a way for applications to drive the
    process of loading an image, by letting them send the image data
    directly to the loader instead of having the loader read the data
    from a file. Applications can use this functionality instead of
    `gdk_pixbuf_new_from_file()` or `gdk_pixbuf_animation_new_from_file()`
    when they need to parse image data in small chunks. For example,
    it should be used when reading an image from a (potentially) slow
    network connection, or when loading an extremely large file.

    To use `GdkPixbufLoader` to load an image, create a new instance,
    and call [method@GdkPixbuf.PixbufLoader.write] to send the data
    to it. When done, [method@GdkPixbuf.PixbufLoader.close] should be
    called to end the stream and finalize everything.

    The loader will emit three important signals throughout the process:

     - [signal@GdkPixbuf.PixbufLoader::size-prepared] will be emitted as
       soon as the image has enough information to determine the size of
       the image to be used. If you want to scale the image while loading
       it, you can call [method@GdkPixbuf.PixbufLoader.set_size] in
       response to this signal.
     - [signal@GdkPixbuf.PixbufLoader::area-prepared] will be emitted as
       soon as the pixbuf of the desired has been allocated. You can obtain
       the `GdkPixbuf` instance by calling [method@GdkPixbuf.PixbufLoader.get_pixbuf].
       If you want to use it, simply acquire a reference to it. You can
       also call `gdk_pixbuf_loader_get_pixbuf()` later to get the same
       pixbuf.
     - [signal@GdkPixbuf.PixbufLoader::area-updated] will be emitted every
       time a region is updated. This way you can update a partially
       completed image. Note that you do not know anything about the
       completeness of an image from the updated area. For example, in an
       interlaced image you will need to make several passes before the
       image is done loading.

    ## Loading an animation

    Loading an animation is almost as easy as loading an image. Once the
    first [signal@GdkPixbuf.PixbufLoader::area-prepared] signal has been
    emitted, you can call [method@GdkPixbuf.PixbufLoader.get_animation] to
    get the [class@GdkPixbuf.PixbufAnimation] instance, and then call
    and [method@GdkPixbuf.PixbufAnimation.get_iter] to get a
    [class@GdkPixbuf.PixbufAnimationIter] to retrieve the pixbuf for the
    desired time stamp.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls) -> PixbufLoader:
        """
        Creates a new pixbuf loader object.
        """
        ...


    @classmethod
    def new_with_mime_type(cls, mime_type: str) -> PixbufLoader:
        """
        Creates a new pixbuf loader object that always attempts to parse
        image data as if it were an image of MIME type @mime_type, instead of
        identifying the type automatically.

        This function is useful if you want an error if the image isn't the
        expected MIME type; for loading image formats that can't be reliably
        identified by looking at the data; or if the user manually forces a
        specific MIME type.

        The list of supported mime types depends on what image loaders
        are installed, but typically "image/png", "image/jpeg", "image/gif",
        "image/tiff" and "image/x-xpixmap" are among the supported mime types.
        To obtain the full list of supported mime types, call
        gdk_pixbuf_format_get_mime_types() on each of the #GdkPixbufFormat
        structs returned by gdk_pixbuf_get_formats().
        """
        ...


    @classmethod
    def new_with_type(cls, image_type: str) -> PixbufLoader:
        """
        Creates a new pixbuf loader object that always attempts to parse
        image data as if it were an image of type @image_type, instead of
        identifying the type automatically.

        This function is useful if you want an error if the image isn't the
        expected type; for loading image formats that can't be reliably
        identified by looking at the data; or if the user manually forces
        a specific type.

        The list of supported image formats depends on what image loaders
        are installed, but typically "png", "jpeg", "gif", "tiff" and
        "xpm" are among the supported formats. To obtain the full list of
        supported image formats, call gdk_pixbuf_format_get_name() on each
        of the #GdkPixbufFormat structs returned by gdk_pixbuf_get_formats().
        """
        ...

    def close(self) -> bool:
        """
        Informs a pixbuf loader that no further writes with
        gdk_pixbuf_loader_write() will occur, so that it can free its
        internal loading structures.

        This function also tries to parse any data that hasn't yet been parsed;
        if the remaining data is partial or corrupt, an error will be returned.

        If `FALSE` is returned, `error` will be set to an error from the
        `GDK_PIXBUF_ERROR` or `G_FILE_ERROR` domains.

        If you're just cancelling a load rather than expecting it to be finished,
        passing `NULL` for `error` to ignore it is reasonable.

        Remember that this function does not release a reference on the loader, so
        you will need to explicitly release any reference you hold.
        """
        ...

    def get_animation(self) -> PixbufAnimation:
        """
        Queries the #GdkPixbufAnimation that a pixbuf loader is currently creating.

        In general it only makes sense to call this function after the
        [signal@GdkPixbuf.PixbufLoader::area-prepared] signal has been emitted by
        the loader.

        If the loader doesn't have enough bytes yet, and hasn't emitted the `area-prepared`
        signal, this function will return `NULL`.
        """
        ...

    def get_format(self) -> PixbufFormat:
        """
        Obtains the available information about the format of the
        currently loading image file.
        """
        ...

    def get_pixbuf(self) -> Pixbuf:
        """
        Queries the #GdkPixbuf that a pixbuf loader is currently creating.

        In general it only makes sense to call this function after the
        [signal@GdkPixbuf.PixbufLoader::area-prepared] signal has been
        emitted by the loader; this means that enough data has been read
        to know the size of the image that will be allocated.

        If the loader has not received enough data via gdk_pixbuf_loader_write(),
        then this function returns `NULL`.

        The returned pixbuf will be the same in all future calls to the loader,
        so if you want to keep using it, you should acquire a reference to it.

        Additionally, if the loader is an animation, it will return the "static
        image" of the animation (see gdk_pixbuf_animation_get_static_image()).
        """
        ...

    def set_size(self, width: int, height: int) -> object:
        """
        Causes the image to be scaled while it is loaded.

        The desired image size can be determined relative to the original
        size of the image by calling gdk_pixbuf_loader_set_size() from a
        signal handler for the ::size-prepared signal.

        Attempts to set the desired image size  are ignored after the
        emission of the ::size-prepared signal.
        """
        ...

    def write(self, buf: object, count: int) -> bool:
        """
        Parses the next `count` bytes in the given image buffer.
        """
        ...

    def write_bytes(self, buffer: GLib.Bytes) -> bool:
        """
        Parses the next contents of the given image buffer.
        """
        ...


    ...

class PixbufNonAnim(PixbufAnimation):

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls, pixbuf: Pixbuf) -> PixbufAnimation:
        ...


    ...

class PixbufSimpleAnim(PixbufAnimation):
    """
    An opaque struct representing a simple animation.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls, width: int, height: int, rate: float) -> PixbufSimpleAnim:
        """
        Creates a new, empty animation.
        """
        ...

    def add_frame(self, pixbuf: Pixbuf) -> object:
        """
        Adds a new frame to @animation. The @pixbuf must
        have the dimensions specified when the animation
        was constructed.
        """
        ...

    def get_loop(self) -> bool:
        """
        Gets whether @animation should loop indefinitely when it reaches the end.
        """
        ...

    def set_loop(self, loop: bool) -> object:
        """
        Sets whether @animation should loop indefinitely when it reaches the end.
        """
        ...


    ...

class PixbufSimpleAnimIter(PixbufAnimationIter):

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...


