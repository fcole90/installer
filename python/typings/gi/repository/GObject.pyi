"""
Stub file for GObject. Autogenerated with gi-stubgen.
"""

import typing as _T  # noqa
from enum import Enum

from gi.repository import GLib

PARAM_MASK = 255
"""
Mask containing the bits of #GParamSpec.flags which are reserved for GLib.
"""

PARAM_STATIC_STRINGS = 224
"""
#GParamFlags value alias for %G_PARAM_STATIC_NAME | %G_PARAM_STATIC_NICK | %G_PARAM_STATIC_BLURB.

Since 2.13.0
"""

PARAM_USER_SHIFT = 8
"""
Minimum shift count to be used for user defined flags, to be stored in
#GParamSpec.flags. The maximum allowed is 10.
"""

SIGNAL_FLAGS_MASK = 511
"""
A mask for all #GSignalFlags bits.
"""

SIGNAL_MATCH_MASK = 63
"""
A mask for all #GSignalMatchType bits.
"""

TYPE_FLAG_RESERVED_ID_BIT = 1
"""
A bit in the type number that's supposed to be left untouched.
"""

TYPE_FUNDAMENTAL_MAX = 255
"""
An integer constant that represents the number of identifiers reserved
for types that are assigned at compile-time.
"""

TYPE_FUNDAMENTAL_SHIFT = 2
"""
Shift value used in converting numbers to type IDs.
"""

TYPE_RESERVED_BSE_FIRST = 32
"""
First fundamental type number to create a new fundamental type id with
G_TYPE_MAKE_FUNDAMENTAL() reserved for BSE.
"""

TYPE_RESERVED_BSE_LAST = 48
"""
Last fundamental type number reserved for BSE.
"""

TYPE_RESERVED_GLIB_FIRST = 22
"""
First fundamental type number to create a new fundamental type id with
G_TYPE_MAKE_FUNDAMENTAL() reserved for GLib.
"""

TYPE_RESERVED_GLIB_LAST = 31
"""
Last fundamental type number reserved for GLib.
"""

TYPE_RESERVED_USER_FIRST = 49
"""
First available fundamental type number to create new fundamental
type id with G_TYPE_MAKE_FUNDAMENTAL().
"""

VALUE_INTERNED_STRING = 268435456
"""
For string values, indicates that the string contained is canonical and will
exist for the duration of the process. See g_value_set_interned_string().
"""

VALUE_NOCOPY_CONTENTS = 134217728
"""
If passed to G_VALUE_COLLECT(), allocated data won't be copied
but used verbatim. This does not affect ref-counted types like
objects. This does not affect usage of g_value_copy(), the data will
be copied if it is not ref-counted.
"""


class BindingFlags(Enum):
    """
    Flags to be passed to g_object_bind_property() or
    g_object_bind_property_full().

    This enumeration can be extended at later date.
    """
    DEFAULT = 0
    BIDIRECTIONAL = 1
    SYNC_CREATE = 2
    INVERT_BOOLEAN = 4

class ConnectFlags(Enum):
    """
    The connection flags are used to specify the behaviour of a signal's
    connection.
    """
    AFTER = 1
    SWAPPED = 2

class ParamFlags(Enum):
    """
    Through the #GParamFlags flag values, certain aspects of parameters
    can be configured.

    See also: %G_PARAM_STATIC_STRINGS
    """
    READABLE = 1
    WRITABLE = 2
    READWRITE = 3
    CONSTRUCT = 4
    CONSTRUCT_ONLY = 8
    LAX_VALIDATION = 16
    STATIC_NAME = 32
    PRIVATE = 32
    STATIC_NICK = 64
    STATIC_BLURB = 128
    EXPLICIT_NOTIFY = 1073741824
    DEPRECATED = 2147483648

class SignalFlags(Enum):
    """
    The signal flags are used to specify a signal's behaviour.
    """
    RUN_FIRST = 1
    RUN_LAST = 2
    RUN_CLEANUP = 4
    NO_RECURSE = 8
    DETAILED = 16
    ACTION = 32
    NO_HOOKS = 64
    MUST_COLLECT = 128
    DEPRECATED = 256
    ACCUMULATOR_FIRST_RUN = 131072

class SignalMatchType(Enum):
    """
    The match types specify what g_signal_handlers_block_matched(),
    g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
    match signals by.
    """
    ID = 1
    DETAIL = 2
    CLOSURE = 4
    FUNC = 8
    DATA = 16
    UNBLOCKED = 32

class TypeDebugFlags(Enum):
    """
    These flags used to be passed to g_type_init_with_debug_flags() which
    is now deprecated.

    If you need to enable debugging features, use the GOBJECT_DEBUG
    environment variable.
    """
    NONE = 0
    OBJECTS = 1
    SIGNALS = 2
    INSTANCE_COUNT = 4
    MASK = 7

class TypeFlags(Enum):
    """
    Bit masks used to check or determine characteristics of a type.
    """
    ABSTRACT = 16
    VALUE_ABSTRACT = 32
    FINAL = 64

class TypeFundamentalFlags(Enum):
    """
    Bit masks used to check or determine specific characteristics of a
    fundamental type.
    """
    CLASSED = 1
    INSTANTIATABLE = 2
    DERIVABLE = 4
    DEEP_DERIVABLE = 8


def boxed_copy(boxed_type: Type, src_boxed: object) -> object:
    """
    Provide a copy of a boxed structure @src_boxed which is of type @boxed_type.
    """
    ...

def boxed_free(boxed_type: Type, boxed: object) -> object:
    """
    Free the boxed structure @boxed which is of type @boxed_type.
    """
    ...

def boxed_type_register_static(name: str, boxed_copy: BoxedCopyFunc, boxed_free: BoxedFreeFunc) -> Type:
    """
    This function creates a new %G_TYPE_BOXED derived type id for a new
    boxed type with name @name.

    Boxed type handling functions have to be provided to copy and free
    opaque boxed structures of this type.

    For the general case, it is recommended to use G_DEFINE_BOXED_TYPE()
    instead of calling g_boxed_type_register_static() directly. The macro
    will create the appropriate `*_get_type()` function for the boxed type.
    """
    ...

def clear_object(object_ptr: Object) -> object:
    """
    Clears a reference to a #GObject.

    @object_ptr must not be %NULL.

    If the reference is %NULL then this function does nothing.
    Otherwise, the reference count of the object is decreased and the
    pointer is set to %NULL.

    A macro is also included that allows this function to be used without
    pointer casts.
    """
    ...

def clear_signal_handler(handler_id_ptr: int, instance: Object) -> object:
    """
    Disconnects a handler from @instance so it will not be called during
    any future or currently ongoing emissions of the signal it has been
    connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).

    If the handler ID is 0 then this function does nothing.

    There is also a macro version of this function so that the code
    will be inlined.
    """
    ...

def enum_complete_type_info(g_enum_type: Type, info: TypeInfo, const_values: EnumValue) -> object:
    """
    This function is meant to be called from the `complete_type_info`
    function of a #GTypePlugin implementation, as in the following
    example:

    |[<!-- language="C" -->
    static void
    my_enum_complete_type_info (GTypePlugin     *plugin,
                                GType            g_type,
                                GTypeInfo       *info,
                                GTypeValueTable *value_table)
    {
      static const GEnumValue values[] = {
        { MY_ENUM_FOO, "MY_ENUM_FOO", "foo" },
        { MY_ENUM_BAR, "MY_ENUM_BAR", "bar" },
        { 0, NULL, NULL }
      };

      g_enum_complete_type_info (type, info, values);
    }
    ]|
    """
    ...

def enum_get_value(enum_class: EnumClass, value: int) -> EnumValue:
    """
    Returns the #GEnumValue for a value.
    """
    ...

def enum_get_value_by_name(enum_class: EnumClass, name: str) -> EnumValue:
    """
    Looks up a #GEnumValue by name.
    """
    ...

def enum_get_value_by_nick(enum_class: EnumClass, nick: str) -> EnumValue:
    """
    Looks up a #GEnumValue by nickname.
    """
    ...

def enum_register_static(name: str, const_static_values: EnumValue) -> Type:
    """
    Registers a new static enumeration type with the name @name.

    It is normally more convenient to let [glib-mkenums][glib-mkenums],
    generate a my_enum_get_type() function from a usual C enumeration
    definition  than to write one yourself using g_enum_register_static().
    """
    ...

def enum_to_string(g_enum_type: Type, value: int) -> str:
    """
    Pretty-prints @value in the form of the enumâ€™s name.

    This is intended to be used for debugging purposes. The format of the output
    may change in the future.
    """
    ...

def flags_complete_type_info(g_flags_type: Type, info: TypeInfo, const_values: FlagsValue) -> object:
    """
    This function is meant to be called from the complete_type_info()
    function of a #GTypePlugin implementation, see the example for
    g_enum_complete_type_info() above.
    """
    ...

def flags_get_first_value(flags_class: FlagsClass, value: int) -> FlagsValue:
    """
    Returns the first #GFlagsValue which is set in @value.
    """
    ...

def flags_get_value_by_name(flags_class: FlagsClass, name: str) -> FlagsValue:
    """
    Looks up a #GFlagsValue by name.
    """
    ...

def flags_get_value_by_nick(flags_class: FlagsClass, nick: str) -> FlagsValue:
    """
    Looks up a #GFlagsValue by nickname.
    """
    ...

def flags_register_static(name: str, const_static_values: FlagsValue) -> Type:
    """
    Registers a new static flags type with the name @name.

    It is normally more convenient to let [glib-mkenums][glib-mkenums]
    generate a my_flags_get_type() function from a usual C enumeration
    definition than to write one yourself using g_flags_register_static().
    """
    ...

def flags_to_string(flags_type: Type, value: int) -> str:
    """
    Pretty-prints @value in the form of the flag names separated by ` | ` and
    sorted. Any extra bits will be shown at the end as a hexadecimal number.

    This is intended to be used for debugging purposes. The format of the output
    may change in the future.
    """
    ...

def gtype_get_type() -> Type:
    ...

def param_spec_boolean(name: str, nick: str, blurb: str, default_value: bool, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
    property. In many cases, it may be more appropriate to use an enum with
    g_param_spec_enum(), both to improve code clarity by using explicitly named
    values, and to allow for more values to be added in future without breaking
    API.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_boxed(name: str, nick: str, blurb: str, boxed_type: Type, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
    derived property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_char(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.
    """
    ...

def param_spec_double(name: str, nick: str, blurb: str, minimum: float, maximum: float, default_value: float, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
    property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_enum(name: str, nick: str, blurb: str, enum_type: Type, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
    property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_flags(name: str, nick: str, blurb: str, flags_type: Type, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
    property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_float(name: str, nick: str, blurb: str, minimum: float, maximum: float, default_value: float, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_gtype(name: str, nick: str, blurb: str, is_a_type: Type, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecGType instance specifying a
    %G_TYPE_GTYPE property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_int(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_int64(name: str, nick: str, blurb: str, minimum: gint64, maximum: gint64, default_value: gint64, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_long(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_object(name: str, nick: str, blurb: str, object_type: Type, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
    derived property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_override(name: str, overridden: ParamSpec) -> ParamSpec:
    """
    Creates a new property of type #GParamSpecOverride. This is used
    to direct operations to another paramspec, and will not be directly
    useful unless you are implementing a new base type similar to GObject.
    """
    ...

def param_spec_param(name: str, nick: str, blurb: str, param_type: Type, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
    property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_pointer(name: str, nick: str, blurb: str, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecPointer instance specifying a pointer property.
    Where possible, it is better to use g_param_spec_object() or
    g_param_spec_boxed() to expose memory management information.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_string(name: str, nick: str, blurb: str, default_value: _T.Optional[str], flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecString instance.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_uchar(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.
    """
    ...

def param_spec_uint(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_uint64(name: str, nick: str, blurb: str, minimum: guint64, maximum: guint64, default_value: guint64, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
    property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_ulong(name: str, nick: str, blurb: str, minimum: int, maximum: int, default_value: int, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
    property.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_unichar(name: str, nick: str, blurb: str, default_value: str, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
    property. #GValue structures for this property can be accessed with
    g_value_set_uint() and g_value_get_uint().

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_value_array(name: str, nick: str, blurb: str, element_spec: ParamSpec, flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecValueArray instance specifying a
    %G_TYPE_VALUE_ARRAY property. %G_TYPE_VALUE_ARRAY is a
    %G_TYPE_BOXED type, as such, #GValue structures for this property
    can be accessed with g_value_set_boxed() and g_value_get_boxed().

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_spec_variant(name: str, nick: str, blurb: str, type: GLib.VariantType, default_value: _T.Optional[GLib.Variant], flags: ParamFlags) -> ParamSpec:
    """
    Creates a new #GParamSpecVariant instance specifying a #GVariant
    property.

    If @default_value is floating, it is consumed.

    See g_param_spec_internal() for details on property names.
    """
    ...

def param_type_register_static(name: str, pspec_info: ParamSpecTypeInfo) -> Type:
    """
    Registers @name as the name of a new static type derived
    from %G_TYPE_PARAM.

    The type system uses the information contained in the #GParamSpecTypeInfo
    structure pointed to by @info to manage the #GParamSpec type and its
    instances.
    """
    ...

def param_value_convert(pspec: ParamSpec, src_value: Value, dest_value: Value, strict_validation: bool) -> bool:
    """
    Transforms @src_value into @dest_value if possible, and then
    validates @dest_value, in order for it to conform to @pspec.  If
    @strict_validation is %TRUE this function will only succeed if the
    transformed @dest_value complied to @pspec without modifications.

    See also g_value_type_transformable(), g_value_transform() and
    g_param_value_validate().
    """
    ...

def param_value_defaults(pspec: ParamSpec, value: Value) -> bool:
    """
    Checks whether @value contains the default value as specified in @pspec.
    """
    ...

def param_value_set_default(pspec: ParamSpec, value: Value) -> object:
    """
    Sets @value to its default value as specified in @pspec.
    """
    ...

def param_value_validate(pspec: ParamSpec, value: Value) -> bool:
    """
    Ensures that the contents of @value comply with the specifications
    set out by @pspec. For example, a #GParamSpecInt might require
    that integers stored in @value may not be smaller than -42 and not be
    greater than +42. If @value contains an integer outside of this range,
    it is modified accordingly, so the resulting value will fit into the
    range -42 .. +42.
    """
    ...

def param_values_cmp(pspec: ParamSpec, value1: Value, value2: Value) -> int:
    """
    Compares @value1 with @value2 according to @pspec, and return -1, 0 or +1,
    if @value1 is found to be less than, equal to or greater than @value2,
    respectively.
    """
    ...

def pointer_type_register_static(name: str) -> Type:
    """
    Creates a new %G_TYPE_POINTER derived type id for a new
    pointer type with name @name.
    """
    ...

def signal_accumulator_first_wins(ihint: SignalInvocationHint, return_accu: Value, handler_return: Value, dummy: _T.Optional[object]) -> bool:
    """
    A predefined #GSignalAccumulator for signals intended to be used as a
    hook for application code to provide a particular value.  Usually
    only one such value is desired and multiple handlers for the same
    signal don't make much sense (except for the case of the default
    handler defined in the class structure, in which case you will
    usually want the signal connection to override the class handler).

    This accumulator will use the return value from the first signal
    handler that is run as the return value for the signal and not run
    any further handlers (ie: the first handler "wins").
    """
    ...

def signal_accumulator_true_handled(ihint: SignalInvocationHint, return_accu: Value, handler_return: Value, dummy: _T.Optional[object]) -> bool:
    """
    A predefined #GSignalAccumulator for signals that return a
    boolean values. The behavior that this accumulator gives is
    that a return of %TRUE stops the signal emission: no further
    callbacks will be invoked, while a return of %FALSE allows
    the emission to continue. The idea here is that a %TRUE return
    indicates that the callback handled the signal, and no further
    handling is needed.
    """
    ...

def signal_add_emission_hook(signal_id: int, detail: GLib.Quark, hook_func: SignalEmissionHook, hook_data: _T.Optional[object], data_destroy: _T.Optional[GLib.DestroyNotify]) -> int:
    """
    Adds an emission hook for a signal, which will get called for any emission
    of that signal, independent of the instance. This is possible only
    for signals which don't have %G_SIGNAL_NO_HOOKS flag set.
    """
    ...

def signal_chain_from_overridden(instance_and_params: object, return_value: Value) -> object:
    """
    Calls the original class closure of a signal. This function should only
    be called from an overridden class closure; see
    g_signal_override_class_closure() and
    g_signal_override_class_handler().
    """
    ...

def signal_chain_from_overridden_handler(instance: TypeInstance, *args: object) -> object:
    """
    Calls the original class closure of a signal. This function should
    only be called from an overridden class closure; see
    g_signal_override_class_closure() and
    g_signal_override_class_handler().
    """
    ...

def signal_connect_closure(instance: Object, detailed_signal: str, closure: Closure, after: bool) -> int:
    """
    Connects a closure to a signal for a particular object.
    """
    ...

def signal_connect_closure_by_id(instance: Object, signal_id: int, detail: GLib.Quark, closure: Closure, after: bool) -> int:
    """
    Connects a closure to a signal for a particular object.
    """
    ...

def signal_connect_data(instance: Object, detailed_signal: str, c_handler: Callback, data: _T.Optional[object], destroy_data: _T.Optional[ClosureNotify], connect_flags: ConnectFlags) -> int:
    """
    Connects a #GCallback function to a signal for a particular object. Similar
    to g_signal_connect(), but allows to provide a #GClosureNotify for the data
    which will be called when the signal handler is disconnected and no longer
    used. Specify @connect_flags if you need `..._after()` or
    `..._swapped()` variants of this function.
    """
    ...

def signal_connect_object(instance: TypeInstance, detailed_signal: str, c_handler: Callback, gobject: _T.Optional[Object], connect_flags: ConnectFlags) -> int:
    """
    This is similar to g_signal_connect_data(), but uses a closure which
    ensures that the @gobject stays alive during the call to @c_handler
    by temporarily adding a reference count to @gobject.

    When the @gobject is destroyed the signal handler will be automatically
    disconnected.  Note that this is not currently threadsafe (ie:
    emitting a signal while @gobject is being destroyed in another thread
    is not safe).
    """
    ...

def signal_emit(instance: Object, signal_id: int, detail: GLib.Quark, *args: object) -> object:
    """
    Emits a signal. Signal emission is done synchronously.
    The method will only return control after all handlers are called or signal emission was stopped.

    Note that g_signal_emit() resets the return value to the default
    if no handlers are connected, in contrast to g_signal_emitv().
    """
    ...

def signal_emit_by_name(instance: Object, detailed_signal: str, *args: object) -> object:
    """
    Emits a signal. Signal emission is done synchronously.
    The method will only return control after all handlers are called or signal emission was stopped.

    Note that g_signal_emit_by_name() resets the return value to the default
    if no handlers are connected, in contrast to g_signal_emitv().
    """
    ...

def signal_emit_valist(instance: TypeInstance, signal_id: int, detail: GLib.Quark, var_args: list) -> object:
    """
    Emits a signal. Signal emission is done synchronously.
    The method will only return control after all handlers are called or signal emission was stopped.

    Note that g_signal_emit_valist() resets the return value to the default
    if no handlers are connected, in contrast to g_signal_emitv().
    """
    ...

def signal_emitv(instance_and_params: object, signal_id: int, detail: GLib.Quark, return_value: Value) -> object:
    """
    Emits a signal. Signal emission is done synchronously.
    The method will only return control after all handlers are called or signal emission was stopped.

    Note that g_signal_emitv() doesn't change @return_value if no handlers are
    connected, in contrast to g_signal_emit() and g_signal_emit_valist().
    """
    ...

def signal_get_invocation_hint(instance: Object) -> SignalInvocationHint:
    """
    Returns the invocation hint of the innermost signal emission of instance.
    """
    ...

def signal_handler_block(instance: Object, handler_id: int) -> object:
    """
    Blocks a handler of an instance so it will not be called during any
    signal emissions unless it is unblocked again. Thus "blocking" a
    signal handler means to temporarily deactivate it, a signal handler
    has to be unblocked exactly the same amount of times it has been
    blocked before to become active again.

    The @handler_id has to be a valid signal handler id, connected to a
    signal of @instance.
    """
    ...

def signal_handler_disconnect(instance: Object, handler_id: int) -> object:
    """
    Disconnects a handler from an instance so it will not be called during
    any future or currently ongoing emissions of the signal it has been
    connected to. The @handler_id becomes invalid and may be reused.

    The @handler_id has to be a valid signal handler id, connected to a
    signal of @instance.
    """
    ...

def signal_handler_find(instance: Object, mask: SignalMatchType, signal_id: int, detail: GLib.Quark, closure: _T.Optional[Closure], func: _T.Optional[object], data: _T.Optional[object]) -> int:
    """
    Finds the first signal handler that matches certain selection criteria.
    The criteria mask is passed as an OR-ed combination of #GSignalMatchType
    flags, and the criteria values are passed as arguments.
    The match @mask has to be non-0 for successful matches.
    If no handler was found, 0 is returned.
    """
    ...

def signal_handler_is_connected(instance: Object, handler_id: int) -> bool:
    """
    Returns whether @handler_id is the ID of a handler connected to @instance.
    """
    ...

def signal_handler_unblock(instance: Object, handler_id: int) -> object:
    """
    Undoes the effect of a previous g_signal_handler_block() call.  A
    blocked handler is skipped during signal emissions and will not be
    invoked, unblocking it (for exactly the amount of times it has been
    blocked before) reverts its "blocked" state, so the handler will be
    recognized by the signal system and is called upon future or
    currently ongoing signal emissions (since the order in which
    handlers are called during signal emissions is deterministic,
    whether the unblocked handler in question is called as part of a
    currently ongoing emission depends on how far that emission has
    proceeded yet).

    The @handler_id has to be a valid id of a signal handler that is
    connected to a signal of @instance and is currently blocked.
    """
    ...

def signal_handlers_block_matched(instance: Object, mask: SignalMatchType, signal_id: int, detail: GLib.Quark, closure: _T.Optional[Closure], func: _T.Optional[object], data: _T.Optional[object]) -> int:
    """
    Blocks all handlers on an instance that match a certain selection criteria.
    The criteria mask is passed as an OR-ed combination of #GSignalMatchType
    flags, and the criteria values are passed as arguments.
    Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
    or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
    If no handlers were found, 0 is returned, the number of blocked handlers
    otherwise.
    """
    ...

def signal_handlers_destroy(instance: Object) -> object:
    """
    Destroy all signal handlers of a type instance. This function is
    an implementation detail of the #GObject dispose implementation,
    and should not be used outside of the type system.
    """
    ...

def signal_handlers_disconnect_matched(instance: Object, mask: SignalMatchType, signal_id: int, detail: GLib.Quark, closure: _T.Optional[Closure], func: _T.Optional[object], data: _T.Optional[object]) -> int:
    """
    Disconnects all handlers on an instance that match a certain
    selection criteria. The criteria mask is passed as an OR-ed
    combination of #GSignalMatchType flags, and the criteria values are
    passed as arguments.  Passing at least one of the
    %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
    %G_SIGNAL_MATCH_DATA match flags is required for successful
    matches.  If no handlers were found, 0 is returned, the number of
    disconnected handlers otherwise.
    """
    ...

def signal_handlers_unblock_matched(instance: Object, mask: SignalMatchType, signal_id: int, detail: GLib.Quark, closure: _T.Optional[Closure], func: _T.Optional[object], data: _T.Optional[object]) -> int:
    """
    Unblocks all handlers on an instance that match a certain selection
    criteria. The criteria mask is passed as an OR-ed combination of
    #GSignalMatchType flags, and the criteria values are passed as arguments.
    Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
    or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
    If no handlers were found, 0 is returned, the number of unblocked handlers
    otherwise. The match criteria should not apply to any handlers that are
    not currently blocked.
    """
    ...

def signal_has_handler_pending(instance: Object, signal_id: int, detail: GLib.Quark, may_be_blocked: bool) -> bool:
    """
    Returns whether there are any handlers connected to @instance for the
    given signal id and detail.

    If @detail is 0 then it will only match handlers that were connected
    without detail.  If @detail is non-zero then it will match handlers
    connected both without detail and with the given detail.  This is
    consistent with how a signal emitted with @detail would be delivered
    to those handlers.

    Since 2.46 this also checks for a non-default class closure being
    installed, as this is basically always what you want.

    One example of when you might use this is when the arguments to the
    signal are difficult to compute. A class implementor may opt to not
    emit the signal if no one is attached anyway, thus saving the cost
    of building the arguments.
    """
    ...

def signal_is_valid_name(name: str) -> bool:
    """
    Validate a signal name. This can be useful for dynamically-generated signals
    which need to be validated at run-time before actually trying to create them.

    See [canonical parameter names][canonical-parameter-names] for details of
    the rules for valid names. The rules for signal names are the same as those
    for property names.
    """
    ...

def signal_list_ids(itype: Type, n_ids: int) -> object:
    """
    Lists the signals by id that a certain instance or interface type
    created. Further information about the signals can be acquired through
    g_signal_query().
    """
    ...

def signal_lookup(name: str, itype: Type) -> int:
    """
    Given the name of the signal and the type of object it connects to, gets
    the signal's identifying integer. Emitting the signal by number is
    somewhat faster than using the name each time.

    Also tries the ancestors of the given type.

    The type class passed as @itype must already have been instantiated (for
    example, using g_type_class_ref()) for this function to work, as signals are
    always installed during class initialization.

    See g_signal_new() for details on allowed signal names.
    """
    ...

def signal_name(signal_id: int) -> str:
    """
    Given the signal's identifier, finds its name.

    Two different signals may have the same name, if they have differing types.
    """
    ...

def signal_new(signal_name: str, itype: Type, signal_flags: SignalFlags, class_offset: int, accumulator: _T.Optional[SignalAccumulator], accu_data: _T.Optional[object], c_marshaller: _T.Optional[SignalCMarshaller], return_type: Type, n_params: int, *args: object) -> int:
    """
    Creates a new signal. (This is usually done in the class initializer.)

    A signal name consists of segments consisting of ASCII letters and
    digits, separated by either the `-` or `_` character. The first
    character of a signal name must be a letter. Names which violate these
    rules lead to undefined behaviour. These are the same rules as for property
    naming (see g_param_spec_internal()).

    When registering a signal and looking up a signal, either separator can
    be used, but they cannot be mixed. Using `-` is considerably more efficient.
    Using `_` is discouraged.

    If 0 is used for @class_offset subclasses cannot override the class handler
    in their class_init method by doing super_class->signal_handler = my_signal_handler.
    Instead they will have to use g_signal_override_class_handler().

    If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
    the marshaller for this signal. In some simple cases, g_signal_new()
    will use a more optimized c_marshaller and va_marshaller for the signal
    instead of g_cclosure_marshal_generic().

    If @c_marshaller is non-%NULL, you need to also specify a va_marshaller
    using g_signal_set_va_marshaller() or the generic va_marshaller will
    be used.
    """
    ...

def signal_new_class_handler(signal_name: str, itype: Type, signal_flags: SignalFlags, class_handler: _T.Optional[Callback], accumulator: _T.Optional[SignalAccumulator], accu_data: _T.Optional[object], c_marshaller: _T.Optional[SignalCMarshaller], return_type: Type, n_params: int, *args: object) -> int:
    """
    Creates a new signal. (This is usually done in the class initializer.)

    This is a variant of g_signal_new() that takes a C callback instead
    of a class offset for the signal's class handler. This function
    doesn't need a function pointer exposed in the class structure of
    an object definition, instead the function pointer is passed
    directly and can be overridden by derived classes with
    g_signal_override_class_closure() or
    g_signal_override_class_handler()and chained to with
    g_signal_chain_from_overridden() or
    g_signal_chain_from_overridden_handler().

    See g_signal_new() for information about signal names.

    If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
    the marshaller for this signal.
    """
    ...

def signal_new_valist(signal_name: str, itype: Type, signal_flags: SignalFlags, class_closure: _T.Optional[Closure], accumulator: _T.Optional[SignalAccumulator], accu_data: _T.Optional[object], c_marshaller: _T.Optional[SignalCMarshaller], return_type: Type, n_params: int, args: list) -> int:
    """
    Creates a new signal. (This is usually done in the class initializer.)

    See g_signal_new() for details on allowed signal names.

    If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
    the marshaller for this signal.
    """
    ...

def signal_newv(signal_name: str, itype: Type, signal_flags: SignalFlags, class_closure: _T.Optional[Closure], accumulator: _T.Optional[SignalAccumulator], accu_data: _T.Optional[object], c_marshaller: _T.Optional[SignalCMarshaller], return_type: Type, n_params: int, param_types: _T.Optional[object]) -> int:
    """
    Creates a new signal. (This is usually done in the class initializer.)

    See g_signal_new() for details on allowed signal names.

    If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
    the marshaller for this signal.
    """
    ...

def signal_override_class_closure(signal_id: int, instance_type: Type, class_closure: Closure) -> object:
    """
    Overrides the class closure (i.e. the default handler) for the given signal
    for emissions on instances of @instance_type. @instance_type must be derived
    from the type to which the signal belongs.

    See g_signal_chain_from_overridden() and
    g_signal_chain_from_overridden_handler() for how to chain up to the
    parent class closure from inside the overridden one.
    """
    ...

def signal_override_class_handler(signal_name: str, instance_type: Type, class_handler: Callback) -> object:
    """
    Overrides the class closure (i.e. the default handler) for the
    given signal for emissions on instances of @instance_type with
    callback @class_handler. @instance_type must be derived from the
    type to which the signal belongs.

    See g_signal_chain_from_overridden() and
    g_signal_chain_from_overridden_handler() for how to chain up to the
    parent class closure from inside the overridden one.
    """
    ...

def signal_parse_name(detailed_signal: str, itype: Type, signal_id_p: int, detail_p: GLib.Quark, force_detail_quark: bool) -> bool:
    """
    Internal function to parse a signal name into its @signal_id
    and @detail quark.
    """
    ...

def signal_query(signal_id: int, query: SignalQuery) -> object:
    """
    Queries the signal system for in-depth information about a
    specific signal. This function will fill in a user-provided
    structure to hold signal-specific information. If an invalid
    signal id is passed in, the @signal_id member of the #GSignalQuery
    is 0. All members filled into the #GSignalQuery structure should
    be considered constant and have to be left untouched.
    """
    ...

def signal_remove_emission_hook(signal_id: int, hook_id: int) -> object:
    """
    Deletes an emission hook.
    """
    ...

def signal_set_va_marshaller(signal_id: int, instance_type: Type, va_marshaller: SignalCVaMarshaller) -> object:
    """
    Change the #GSignalCVaMarshaller used for a given signal.  This is a
    specialised form of the marshaller that can often be used for the
    common case of a single connected signal handler and avoids the
    overhead of #GValue.  Its use is optional.
    """
    ...

def signal_stop_emission(instance: Object, signal_id: int, detail: GLib.Quark) -> object:
    """
    Stops a signal's current emission.

    This will prevent the default method from running, if the signal was
    %G_SIGNAL_RUN_LAST and you connected normally (i.e. without the "after"
    flag).

    Prints a warning if used on a signal which isn't being emitted.
    """
    ...

def signal_stop_emission_by_name(instance: Object, detailed_signal: str) -> object:
    """
    Stops a signal's current emission.

    This is just like g_signal_stop_emission() except it will look up the
    signal id for you.
    """
    ...

def signal_type_cclosure_new(itype: Type, struct_offset: int) -> Closure:
    """
    Creates a new closure which invokes the function found at the offset
    @struct_offset in the class structure of the interface or classed type
    identified by @itype.
    """
    ...

def source_set_closure(source: GLib.Source, closure: Closure) -> object:
    """
    Set the callback for a source as a #GClosure.

    If the source is not one of the standard GLib types, the @closure_callback
    and @closure_marshal fields of the #GSourceFuncs structure must have been
    filled in with pointers to appropriate functions.
    """
    ...

def source_set_dummy_callback(source: GLib.Source) -> object:
    """
    Sets a dummy callback for @source. The callback will do nothing, and
    if the source expects a #gboolean return value, it will return %TRUE.
    (If the source expects any other type of return value, it will return
    a 0/%NULL value; whatever g_value_init() initializes a #GValue to for
    that type.)

    If the source is not one of the standard GLib types, the
    @closure_callback and @closure_marshal fields of the #GSourceFuncs
    structure must have been filled in with pointers to appropriate
    functions.
    """
    ...

def strdup_value_contents(value: Value) -> str:
    """
    Return a newly allocated string, which describes the contents of a
    #GValue.  The main purpose of this function is to describe #GValue
    contents for debugging output, the way in which the contents are
    described may change between different GLib versions.
    """
    ...

def type_add_class_cache_func(cache_data: _T.Optional[object], cache_func: TypeClassCacheFunc) -> object:
    """
    Adds a #GTypeClassCacheFunc to be called before the reference count of a
    class goes from one to zero. This can be used to prevent premature class
    destruction. All installed #GTypeClassCacheFunc functions will be chained
    until one of them returns %TRUE. The functions have to check the class id
    passed in to figure whether they actually want to cache the class of this
    type, since all classes are routed through the same #GTypeClassCacheFunc
    chain.
    """
    ...

def type_add_class_private(class_type: Type, private_size: int) -> object:
    """
    Registers a private class structure for a classed type;
    when the class is allocated, the private structures for
    the class and all of its parent types are allocated
    sequentially in the same memory block as the public
    structures, and are zero-filled.

    This function should be called in the
    type's get_type() function after the type is registered.
    The private structure can be retrieved using the
    G_TYPE_CLASS_GET_PRIVATE() macro.
    """
    ...

def type_add_instance_private(class_type: Type, private_size: int) -> int:
    ...

def type_add_interface_check(check_data: _T.Optional[object], check_func: TypeInterfaceCheckFunc) -> object:
    """
    Adds a function to be called after an interface vtable is
    initialized for any class (i.e. after the @interface_init
    member of #GInterfaceInfo has been called).

    This function is useful when you want to check an invariant
    that depends on the interfaces of a class. For instance, the
    implementation of #GObject uses this facility to check that an
    object implements all of the properties that are defined on its
    interfaces.
    """
    ...

def type_add_interface_dynamic(instance_type: Type, interface_type: Type, plugin: TypePlugin) -> object:
    """
    Adds @interface_type to the dynamic @instance_type. The information
    contained in the #GTypePlugin structure pointed to by @plugin
    is used to manage the relationship.
    """
    ...

def type_add_interface_static(instance_type: Type, interface_type: Type, info: InterfaceInfo) -> object:
    """
    Adds @interface_type to the static @instance_type.
    The information contained in the #GInterfaceInfo structure
    pointed to by @info is used to manage the relationship.
    """
    ...

def type_check_class_cast(g_class: TypeClass, is_a_type: Type) -> TypeClass:
    ...

def type_check_class_is_a(g_class: TypeClass, is_a_type: Type) -> bool:
    ...

def type_check_instance(instance: TypeInstance) -> bool:
    """
    Private helper function to aid implementation of the
    G_TYPE_CHECK_INSTANCE() macro.
    """
    ...

def type_check_instance_cast(instance: TypeInstance, iface_type: Type) -> TypeInstance:
    ...

def type_check_instance_is_a(instance: TypeInstance, iface_type: Type) -> bool:
    ...

def type_check_instance_is_fundamentally_a(instance: TypeInstance, fundamental_type: Type) -> bool:
    ...

def type_check_is_value_type(type: Type) -> bool:
    ...

def type_check_value(value: Value) -> bool:
    ...

def type_check_value_holds(value: Value, type: Type) -> bool:
    ...

def type_children(type: Type, n_children: int) -> object:
    """
    Return a newly allocated and 0-terminated array of type IDs, listing
    the child types of @type.
    """
    ...

def type_create_instance(type: Type) -> TypeInstance:
    """
    Creates and initializes an instance of @type if @type is valid and
    can be instantiated. The type system only performs basic allocation
    and structure setups for instances: actual instance creation should
    happen through functions supplied by the type's fundamental type
    implementation.  So use of g_type_create_instance() is reserved for
    implementers of fundamental types only. E.g. instances of the
    #GObject hierarchy should be created via g_object_new() and never
    directly through g_type_create_instance() which doesn't handle things
    like singleton objects or object construction.

    The extended members of the returned instance are guaranteed to be filled
    with zeros.

    Note: Do not use this function, unless you're implementing a
    fundamental type. Also language bindings should not use this
    function, but g_object_new() instead.
    """
    ...

def type_default_interface_peek(g_type: Type) -> TypeInterface:
    """
    If the interface type @g_type is currently in use, returns its
    default interface vtable.
    """
    ...

def type_default_interface_ref(g_type: Type) -> TypeInterface:
    """
    Increments the reference count for the interface type @g_type,
    and returns the default interface vtable for the type.

    If the type is not currently in use, then the default vtable
    for the type will be created and initialized by calling
    the base interface init and default vtable init functions for
    the type (the @base_init and @class_init members of #GTypeInfo).
    Calling g_type_default_interface_ref() is useful when you
    want to make sure that signals and properties for an interface
    have been installed.
    """
    ...

def type_default_interface_unref(g_iface: TypeInterface) -> object:
    """
    Decrements the reference count for the type corresponding to the
    interface default vtable @g_iface. If the type is dynamic, then
    when no one is using the interface and all references have
    been released, the finalize function for the interface's default
    vtable (the @class_finalize member of #GTypeInfo) will be called.
    """
    ...

def type_depth(type: Type) -> int:
    """
    Returns the length of the ancestry of the passed in type. This
    includes the type itself, so that e.g. a fundamental type has depth 1.
    """
    ...

def type_ensure(type: Type) -> object:
    """
    Ensures that the indicated @type has been registered with the
    type system, and its _class_init() method has been run.

    In theory, simply calling the type's _get_type() method (or using
    the corresponding macro) is supposed take care of this. However,
    _get_type() methods are often marked %G_GNUC_CONST for performance
    reasons, even though this is technically incorrect (since
    %G_GNUC_CONST requires that the function not have side effects,
    which _get_type() methods do on the first call). As a result, if
    you write a bare call to a _get_type() macro, it may get optimized
    out by the compiler. Using g_type_ensure() guarantees that the
    type's _get_type() method is called.
    """
    ...

def type_free_instance(instance: TypeInstance) -> object:
    """
    Frees an instance of a type, returning it to the instance pool for
    the type, if there is one.

    Like g_type_create_instance(), this function is reserved for
    implementors of fundamental types.
    """
    ...

def type_from_name(name: str) -> Type:
    """
    Look up the type ID from a given type name, returning 0 if no type
    has been registered under this name (this is the preferred method
    to find out by name whether a specific type has been registered
    yet).
    """
    ...

def type_fundamental(type_id: Type) -> Type:
    """
    Internal function, used to extract the fundamental type ID portion.
    Use G_TYPE_FUNDAMENTAL() instead.
    """
    ...

def type_fundamental_next() -> Type:
    """
    Returns the next free fundamental type id which can be used to
    register a new fundamental type with g_type_register_fundamental().
    The returned type ID represents the highest currently registered
    fundamental type identifier.
    """
    ...

def type_get_instance_count(type: Type) -> int:
    """
    Returns the number of instances allocated of the particular type;
    this is only available if GLib is built with debugging support and
    the instance_count debug flag is set (by setting the GOBJECT_DEBUG
    variable to include instance-count).
    """
    ...

def type_get_plugin(type: Type) -> TypePlugin:
    """
    Returns the #GTypePlugin structure for @type.
    """
    ...

def type_get_qdata(type: Type, quark: GLib.Quark) -> object:
    """
    Obtains data which has previously been attached to @type
    with g_type_set_qdata().

    Note that this does not take subtyping into account; data
    attached to one type with g_type_set_qdata() cannot
    be retrieved from a subtype using g_type_get_qdata().
    """
    ...

def type_get_type_registration_serial() -> int:
    """
    Returns an opaque serial number that represents the state of the set
    of registered types. Any time a type is registered this serial changes,
    which means you can cache information based on type lookups (such as
    g_type_from_name()) and know if the cache is still valid at a later
    time by comparing the current serial with the one at the type lookup.
    """
    ...

def type_init() -> object:
    """
    This function used to initialise the type system.  Since GLib 2.36,
    the type system is initialised automatically and this function does
    nothing.
    """
    ...

def type_init_with_debug_flags(debug_flags: TypeDebugFlags) -> object:
    """
    This function used to initialise the type system with debugging
    flags.  Since GLib 2.36, the type system is initialised automatically
    and this function does nothing.

    If you need to enable debugging features, use the GOBJECT_DEBUG
    environment variable.
    """
    ...

def type_interfaces(type: Type, n_interfaces: int) -> object:
    """
    Return a newly allocated and 0-terminated array of type IDs, listing
    the interface types that @type conforms to.
    """
    ...

def type_is_a(type: Type, is_a_type: Type) -> bool:
    """
    If @is_a_type is a derivable type, check whether @type is a
    descendant of @is_a_type. If @is_a_type is an interface, check
    whether @type conforms to it.
    """
    ...

def type_name(type: Type) -> str:
    """
    Get the unique name that is assigned to a type ID.  Note that this
    function (like all other GType API) cannot cope with invalid type
    IDs. %G_TYPE_INVALID may be passed to this function, as may be any
    other validly registered type ID, but randomized type IDs should
    not be passed in and will most likely lead to a crash.
    """
    ...

def type_name_from_class(g_class: TypeClass) -> str:
    ...

def type_name_from_instance(instance: TypeInstance) -> str:
    ...

def type_next_base(leaf_type: Type, root_type: Type) -> Type:
    """
    Given a @leaf_type and a @root_type which is contained in its
    ancestry, return the type that @root_type is the immediate parent
    of. In other words, this function determines the type that is
    derived directly from @root_type which is also a base class of
    @leaf_type.  Given a root type and a leaf type, this function can
    be used to determine the types and order in which the leaf type is
    descended from the root type.
    """
    ...

def type_parent(type: Type) -> Type:
    """
    Return the direct parent type of the passed in type. If the passed
    in type has no parent, i.e. is a fundamental type, 0 is returned.
    """
    ...

def type_qname(type: Type) -> GLib.Quark:
    """
    Get the corresponding quark of the type IDs name.
    """
    ...

def type_query(type: Type, query: TypeQuery) -> object:
    """
    Queries the type system for information about a specific type.
    This function will fill in a user-provided structure to hold
    type-specific information. If an invalid #GType is passed in, the
    @type member of the #GTypeQuery is 0. All members filled into the
    #GTypeQuery structure should be considered constant and have to be
    left untouched.
    """
    ...

def type_register_dynamic(parent_type: Type, type_name: str, plugin: TypePlugin, flags: TypeFlags) -> Type:
    """
    Registers @type_name as the name of a new dynamic type derived from
    @parent_type.  The type system uses the information contained in the
    #GTypePlugin structure pointed to by @plugin to manage the type and its
    instances (if not abstract).  The value of @flags determines the nature
    (e.g. abstract or not) of the type.
    """
    ...

def type_register_fundamental(type_id: Type, type_name: str, info: TypeInfo, finfo: TypeFundamentalInfo, flags: TypeFlags) -> Type:
    """
    Registers @type_id as the predefined identifier and @type_name as the
    name of a fundamental type. If @type_id is already registered, or a
    type named @type_name is already registered, the behaviour is undefined.
    The type system uses the information contained in the #GTypeInfo structure
    pointed to by @info and the #GTypeFundamentalInfo structure pointed to by
    @finfo to manage the type and its instances. The value of @flags determines
    additional characteristics of the fundamental type.
    """
    ...

def type_register_static(parent_type: Type, type_name: str, info: TypeInfo, flags: TypeFlags) -> Type:
    """
    Registers @type_name as the name of a new static type derived from
    @parent_type. The type system uses the information contained in the
    #GTypeInfo structure pointed to by @info to manage the type and its
    instances (if not abstract). The value of @flags determines the nature
    (e.g. abstract or not) of the type.
    """
    ...

def type_register_static_simple(parent_type: Type, type_name: str, class_size: int, class_init: ClassInitFunc, instance_size: int, instance_init: InstanceInitFunc, flags: TypeFlags) -> Type:
    """
    Registers @type_name as the name of a new static type derived from
    @parent_type.  The value of @flags determines the nature (e.g.
    abstract or not) of the type. It works by filling a #GTypeInfo
    struct and calling g_type_register_static().
    """
    ...

def type_remove_class_cache_func(cache_data: _T.Optional[object], cache_func: TypeClassCacheFunc) -> object:
    """
    Removes a previously installed #GTypeClassCacheFunc. The cache
    maintained by @cache_func has to be empty when calling
    g_type_remove_class_cache_func() to avoid leaks.
    """
    ...

def type_remove_interface_check(check_data: _T.Optional[object], check_func: TypeInterfaceCheckFunc) -> object:
    """
    Removes an interface check function added with
    g_type_add_interface_check().
    """
    ...

def type_set_qdata(type: Type, quark: GLib.Quark, data: _T.Optional[object]) -> object:
    """
    Attaches arbitrary data to a type.
    """
    ...

def type_test_flags(type: Type, flags: int) -> bool:
    ...

class Binding(Object):
    """
    #GBinding is the representation of a binding between a property on a
    #GObject instance (or source) and another property on another #GObject
    instance (or target).

    Whenever the source property changes, the same value is applied to the
    target property; for instance, the following binding:

    |[<!-- language="C" -->
      g_object_bind_property (object1, "property-a",
                              object2, "property-b",
                              G_BINDING_DEFAULT);
    ]|

    will cause the property named "property-b" of @object2 to be updated
    every time g_object_set() or the specific accessor changes the value of
    the property "property-a" of @object1.

    It is possible to create a bidirectional binding between two properties
    of two #GObject instances, so that if either property changes, the
    other is updated as well, for instance:

    |[<!-- language="C" -->
      g_object_bind_property (object1, "property-a",
                              object2, "property-b",
                              G_BINDING_BIDIRECTIONAL);
    ]|

    will keep the two properties in sync.

    It is also possible to set a custom transformation function (in both
    directions, in case of a bidirectional binding) to apply a custom
    transformation from the source value to the target value before
    applying it; for instance, the following binding:

    |[<!-- language="C" -->
      g_object_bind_property_full (adjustment1, "value",
                                   adjustment2, "value",
                                   G_BINDING_BIDIRECTIONAL,
                                   celsius_to_fahrenheit,
                                   fahrenheit_to_celsius,
                                   NULL, NULL);
    ]|

    will keep the "value" property of the two adjustments in sync; the
    @celsius_to_fahrenheit function will be called whenever the "value"
    property of @adjustment1 changes and will transform the current value
    of the property before applying it to the "value" property of @adjustment2.

    Vice versa, the @fahrenheit_to_celsius function will be called whenever
    the "value" property of @adjustment2 changes, and will transform the
    current value of the property before applying it to the "value" property
    of @adjustment1.

    Note that #GBinding does not resolve cycles by itself; a cycle like

    |[
      object1:propertyA -> object2:propertyB
      object2:propertyB -> object3:propertyC
      object3:propertyC -> object1:propertyA
    ]|

    might lead to an infinite loop. The loop, in this particular case,
    can be avoided if the objects emit the #GObject::notify signal only
    if the value has effectively been changed. A binding is implemented
    using the #GObject::notify signal, so it is susceptible to all the
    various ways of blocking a signal emission, like g_signal_stop_emission()
    or g_signal_handler_block().

    A binding will be severed, and the resources it allocates freed, whenever
    either one of the #GObject instances it refers to are finalized, or when
    the #GBinding instance loses its last reference.

    Bindings for languages with garbage collection can use
    g_binding_unbind() to explicitly release a binding between the source
    and target properties, instead of relying on the last reference on the
    binding, source, and target instances to drop.

    #GBinding is available since GObject 2.26
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...

    def dup_source(self) -> Object:
        """
        Retrieves the #GObject instance used as the source of the binding.

        A #GBinding can outlive the source #GObject as the binding does not hold a
        strong reference to the source. If the source is destroyed before the
        binding then this function will return %NULL.
        """
        ...

    def dup_target(self) -> Object:
        """
        Retrieves the #GObject instance used as the target of the binding.

        A #GBinding can outlive the target #GObject as the binding does not hold a
        strong reference to the target. If the target is destroyed before the
        binding then this function will return %NULL.
        """
        ...

    def get_flags(self) -> BindingFlags:
        """
        Retrieves the flags passed when constructing the #GBinding.
        """
        ...

    def get_source(self) -> Object:
        """
        Retrieves the #GObject instance used as the source of the binding.

        A #GBinding can outlive the source #GObject as the binding does not hold a
        strong reference to the source. If the source is destroyed before the
        binding then this function will return %NULL.

        Use g_binding_dup_source() if the source or binding are used from different
        threads as otherwise the pointer returned from this function might become
        invalid if the source is finalized from another thread in the meantime.
        """
        ...

    def get_source_property(self) -> str:
        """
        Retrieves the name of the property of #GBinding:source used as the source
        of the binding.
        """
        ...

    def get_target(self) -> Object:
        """
        Retrieves the #GObject instance used as the target of the binding.

        A #GBinding can outlive the target #GObject as the binding does not hold a
        strong reference to the target. If the target is destroyed before the
        binding then this function will return %NULL.

        Use g_binding_dup_target() if the target or binding are used from different
        threads as otherwise the pointer returned from this function might become
        invalid if the target is finalized from another thread in the meantime.
        """
        ...

    def get_target_property(self) -> str:
        """
        Retrieves the name of the property of #GBinding:target used as the target
        of the binding.
        """
        ...

    def unbind(self) -> object:
        """
        Explicitly releases the binding between the source and the target
        property expressed by @binding.

        This function will release the reference that is being held on
        the @binding instance if the binding is still bound; if you want to hold on
        to the #GBinding instance after calling g_binding_unbind(), you will need
        to hold a reference to it.

        Note however that this function does not take ownership of @binding, it
        only unrefs the reference that was initially created by
        g_object_bind_property() and is owned by the binding.
        """
        ...


    ...

class BindingGroup(Object):
    """
    The #GBindingGroup can be used to bind multiple properties
    from an object collectively.

    Use the various methods to bind properties from a single source
    object to multiple destination objects. Properties can be bound
    bidirectionally and are connected when the source object is set
    with g_binding_group_set_source().
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls) -> BindingGroup:
        """
        Creates a new #GBindingGroup.
        """
        ...

    def bind(self, source_property: str, target: Object, target_property: str, flags: BindingFlags) -> object:
        """
        Creates a binding between @source_property on the source object
        and @target_property on @target. Whenever the @source_property
        is changed the @target_property is updated using the same value.
        The binding flag %G_BINDING_SYNC_CREATE is automatically specified.

        See g_object_bind_property() for more information.
        """
        ...

    def bind_full(self, source_property: str, target: Object, target_property: str, flags: BindingFlags, transform_to: _T.Optional[BindingTransformFunc], transform_from: _T.Optional[BindingTransformFunc], user_data: _T.Optional[object], user_data_destroy: GLib.DestroyNotify) -> object:
        """
        Creates a binding between @source_property on the source object and
        @target_property on @target, allowing you to set the transformation
        functions to be used by the binding. The binding flag
        %G_BINDING_SYNC_CREATE is automatically specified.

        See g_object_bind_property_full() for more information.
        """
        ...

    def bind_with_closures(self, source_property: str, target: Object, target_property: str, flags: BindingFlags, transform_to: _T.Optional[Closure], transform_from: _T.Optional[Closure]) -> object:
        """
        Creates a binding between @source_property on the source object and
        @target_property on @target, allowing you to set the transformation
        functions to be used by the binding. The binding flag
        %G_BINDING_SYNC_CREATE is automatically specified.

        This function is the language bindings friendly version of
        g_binding_group_bind_property_full(), using #GClosures
        instead of function pointers.

        See g_object_bind_property_with_closures() for more information.
        """
        ...

    def dup_source(self) -> Object:
        """
        Gets the source object used for binding properties.
        """
        ...

    def set_source(self, source: _T.Optional[Object]) -> object:
        """
        Sets @source as the source object used for creating property
        bindings. If there is already a source object all bindings from it
        will be removed.

        Note that all properties that have been bound must exist on @source.
        """
        ...


    ...

class InitiallyUnowned(Object):
    """
    A type for objects that have an initially floating reference.

    All the fields in the `GInitiallyUnowned` structure are private to the
    implementation and should never be accessed directly.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class Object(object):
    """
    The base object type.

    All the fields in the `GObject` structure are private to the implementation
    and should never be accessed directly.

    Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
    alignment of the largest basic GLib type (typically this is #guint64 or
    #gdouble). If you need larger alignment for an element in a #GObject, you
    should allocate it on the heap (aligned), or arrange for your #GObject to be
    appropriately padded. This guarantee applies to the #GObject (or derived)
    struct, the #GObjectClass (or derived) struct, and any private data allocated
    by G_ADD_PRIVATE().
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls, object_type: Type, first_property_name: str, *args: object) -> Object:
        """
        Creates a new instance of a #GObject subtype and sets its properties.

        Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
        which are not explicitly specified are set to their default values. Any
        private data for the object is guaranteed to be initialized with zeros, as
        per g_type_create_instance().

        Note that in C, small integer types in variable argument lists are promoted
        up to #gint or #guint as appropriate, and read back accordingly. #gint is 32
        bits on every platform on which GLib is currently supported. This means that
        you can use C expressions of type #gint with g_object_new() and properties of
        type #gint or #guint or smaller. Specifically, you can use integer literals
        with these property types.

        When using property types of #gint64 or #guint64, you must ensure that the
        value that you provide is 64 bit. This means that you should use a cast or
        make use of the %G_GINT64_CONSTANT or %G_GUINT64_CONSTANT macros.

        Similarly, #gfloat is promoted to #gdouble, so you must ensure that the value
        you provide is a #gdouble, even for a property of type #gfloat.

        Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the
        alignment of the largest basic GLib type (typically this is #guint64 or
        #gdouble). If you need larger alignment for an element in a #GObject, you
        should allocate it on the heap (aligned), or arrange for your #GObject to be
        appropriately padded.
        """
        ...


    @classmethod
    def new_valist(cls, object_type: Type, first_property_name: str, var_args: list) -> Object:
        """
        Creates a new instance of a #GObject subtype and sets its properties.

        Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
        which are not explicitly specified are set to their default values.
        """
        ...


    @classmethod
    def new_with_properties(cls, object_type: Type, n_properties: int, names: object, values: object) -> Object:
        """
        Creates a new instance of a #GObject subtype and sets its properties using
        the provided arrays. Both arrays must have exactly @n_properties elements,
        and the names and values correspond by index.

        Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
        which are not explicitly specified are set to their default values.
        """
        ...


    @classmethod
    def newv(cls, object_type: Type, n_parameters: int, parameters: object) -> Object:
        """
        Creates a new instance of a #GObject subtype and sets its properties.

        Construction parameters (see %G_PARAM_CONSTRUCT, %G_PARAM_CONSTRUCT_ONLY)
        which are not explicitly specified are set to their default values.
        """
        ...

    def add_toggle_ref(self, notify: ToggleNotify, data: _T.Optional[object]) -> object:
        """
        Increases the reference count of the object by one and sets a
        callback to be called when all other references to the object are
        dropped, or when this is already the last reference to the object
        and another reference is established.

        This functionality is intended for binding @object to a proxy
        object managed by another memory manager. This is done with two
        paired references: the strong reference added by
        g_object_add_toggle_ref() and a reverse reference to the proxy
        object which is either a strong reference or weak reference.

        The setup is that when there are no other references to @object,
        only a weak reference is held in the reverse direction from @object
        to the proxy object, but when there are other references held to
        @object, a strong reference is held. The @notify callback is called
        when the reference from @object to the proxy object should be
        "toggled" from strong to weak (@is_last_ref true) or weak to strong
        (@is_last_ref false).

        Since a (normal) reference must be held to the object before
        calling g_object_add_toggle_ref(), the initial state of the reverse
        link is always strong.

        Multiple toggle references may be added to the same gobject,
        however if there are multiple toggle references to an object, none
        of them will ever be notified until all but one are removed.  For
        this reason, you should only ever use a toggle reference if there
        is important state in the proxy object.
        """
        ...

    def add_weak_pointer(self, weak_pointer_location: object) -> object:
        """
        Adds a weak reference from weak_pointer to @object to indicate that
        the pointer located at @weak_pointer_location is only valid during
        the lifetime of @object. When the @object is finalized,
        @weak_pointer will be set to %NULL.

        Note that as with g_object_weak_ref(), the weak references created by
        this method are not thread-safe: they cannot safely be used in one
        thread if the object's last g_object_unref() might happen in another
        thread. Use #GWeakRef if thread-safety is required.
        """
        ...

    def bind_property(self, source_property: str, target: Object, target_property: str, flags: BindingFlags) -> Binding:
        """
        Creates a binding between @source_property on @source and @target_property
        on @target.

        Whenever the @source_property is changed the @target_property is
        updated using the same value. For instance:

        |[<!-- language="C" -->
          g_object_bind_property (action, "active", widget, "sensitive", 0);
        ]|

        Will result in the "sensitive" property of the widget #GObject instance to be
        updated with the same value of the "active" property of the action #GObject
        instance.

        If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
        if @target_property on @target changes then the @source_property on @source
        will be updated as well.

        The binding will automatically be removed when either the @source or the
        @target instances are finalized. To remove the binding without affecting the
        @source and the @target you can just call g_object_unref() on the returned
        #GBinding instance.

        Removing the binding by calling g_object_unref() on it must only be done if
        the binding, @source and @target are only used from a single thread and it
        is clear that both @source and @target outlive the binding. Especially it
        is not safe to rely on this if the binding, @source or @target can be
        finalized from different threads. Keep another reference to the binding and
        use g_binding_unbind() instead to be on the safe side.

        A #GObject can have multiple bindings.
        """
        ...

    def bind_property_full(self, source_property: str, target: Object, target_property: str, flags: BindingFlags, transform_to: _T.Optional[BindingTransformFunc], transform_from: _T.Optional[BindingTransformFunc], user_data: _T.Optional[object], notify: _T.Optional[GLib.DestroyNotify]) -> Binding:
        """
        Complete version of g_object_bind_property().

        Creates a binding between @source_property on @source and @target_property
        on @target, allowing you to set the transformation functions to be used by
        the binding.

        If @flags contains %G_BINDING_BIDIRECTIONAL then the binding will be mutual:
        if @target_property on @target changes then the @source_property on @source
        will be updated as well. The @transform_from function is only used in case
        of bidirectional bindings, otherwise it will be ignored

        The binding will automatically be removed when either the @source or the
        @target instances are finalized. This will release the reference that is
        being held on the #GBinding instance; if you want to hold on to the
        #GBinding instance, you will need to hold a reference to it.

        To remove the binding, call g_binding_unbind().

        A #GObject can have multiple bindings.

        The same @user_data parameter will be used for both @transform_to
        and @transform_from transformation functions; the @notify function will
        be called once, when the binding is removed. If you need different data
        for each transformation function, please use
        g_object_bind_property_with_closures() instead.
        """
        ...

    def bind_property_with_closures(self, source_property: str, target: Object, target_property: str, flags: BindingFlags, transform_to: Closure, transform_from: Closure) -> Binding:
        """
        Creates a binding between @source_property on @source and @target_property
        on @target, allowing you to set the transformation functions to be used by
        the binding.

        This function is the language bindings friendly version of
        g_object_bind_property_full(), using #GClosures instead of
        function pointers.
        """
        ...

    def connect(self, signal_spec: str, *args: object) -> Object:
        """
        A convenience function to connect multiple signals at once.

        The signal specs expected by this function have the form
        "modifier::signal_name", where modifier can be one of the following:
        - signal: equivalent to g_signal_connect_data (..., NULL, 0)
        - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
        - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
        - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
        - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
        - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
        - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
        - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)

        |[<!-- language="C" -->
          menu->toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
        						   "type", GTK_WINDOW_POPUP,
        						   "child", menu,
        						   NULL),
        				     "signal::event", gtk_menu_window_event, menu,
        				     "signal::size_request", gtk_menu_window_size_request, menu,
        				     "signal::destroy", gtk_widget_destroyed, &menu->toplevel,
        				     NULL);
        ]|
        """
        ...

    def disconnect(self, signal_spec: str, *args: object) -> object:
        """
        A convenience function to disconnect multiple signals at once.

        The signal specs expected by this function have the form
        "any_signal", which means to disconnect any signal with matching
        callback and data, or "any_signal::signal_name", which only
        disconnects the signal named "signal_name".
        """
        ...

    def dup_data(self, key: str, dup_func: _T.Optional[GLib.DuplicateFunc], user_data: _T.Optional[object]) -> object:
        """
        This is a variant of g_object_get_data() which returns
        a 'duplicate' of the value. @dup_func defines the
        meaning of 'duplicate' in this context, it could e.g.
        take a reference on a ref-counted object.

        If the @key is not set on the object then @dup_func
        will be called with a %NULL argument.

        Note that @dup_func is called while user data of @object
        is locked.

        This function can be useful to avoid races when multiple
        threads are using object data on the same key on the same
        object.
        """
        ...

    def dup_qdata(self, quark: GLib.Quark, dup_func: _T.Optional[GLib.DuplicateFunc], user_data: _T.Optional[object]) -> object:
        """
        This is a variant of g_object_get_qdata() which returns
        a 'duplicate' of the value. @dup_func defines the
        meaning of 'duplicate' in this context, it could e.g.
        take a reference on a ref-counted object.

        If the @quark is not set on the object then @dup_func
        will be called with a %NULL argument.

        Note that @dup_func is called while user data of @object
        is locked.

        This function can be useful to avoid races when multiple
        threads are using object data on the same key on the same
        object.
        """
        ...

    def force_floating(self) -> object:
        """
        This function is intended for #GObject implementations to re-enforce
        a [floating][floating-ref] object reference. Doing this is seldom
        required: all #GInitiallyUnowneds are created with a floating reference
        which usually just needs to be sunken by calling g_object_ref_sink().
        """
        ...

    def freeze_notify(self) -> object:
        """
        Increases the freeze count on @object. If the freeze count is
        non-zero, the emission of "notify" signals on @object is
        stopped. The signals are queued until the freeze count is decreased
        to zero. Duplicate notifications are squashed so that at most one
        #GObject::notify signal is emitted for each property modified while the
        object is frozen.

        This is necessary for accessors that modify multiple properties to prevent
        premature notification while the object is still being modified.
        """
        ...

    def get(self, first_property_name: str, *args: object) -> object:
        """
        Gets properties of an object.

        In general, a copy is made of the property contents and the caller
        is responsible for freeing the memory in the appropriate manner for
        the type, for instance by calling g_free() or g_object_unref().

        Here is an example of using g_object_get() to get the contents
        of three properties: an integer, a string and an object:
        |[<!-- language="C" -->
         gint intval;
         guint64 uint64val;
         gchar *strval;
         GObject *objval;

         g_object_get (my_object,
                       "int-property", &intval,
                       "uint64-property", &uint64val,
                       "str-property", &strval,
                       "obj-property", &objval,
                       NULL);

         // Do something with intval, uint64val, strval, objval

         g_free (strval);
         g_object_unref (objval);
        ]|
        """
        ...

    def get_data(self, key: str) -> object:
        """
        Gets a named field from the objects table of associations (see g_object_set_data()).
        """
        ...

    def get_property(self, property_name: str, value: Value) -> object:
        """
        Gets a property of an object.

        The @value can be:

         - an empty #GValue initialized by %G_VALUE_INIT, which will be
           automatically initialized with the expected type of the property
           (since GLib 2.60)
         - a #GValue initialized with the expected type of the property
         - a #GValue initialized with a type to which the expected type
           of the property can be transformed

        In general, a copy is made of the property contents and the caller is
        responsible for freeing the memory by calling g_value_unset().

        Note that g_object_get_property() is really intended for language
        bindings, g_object_get() is much more convenient for C programming.
        """
        ...

    def get_qdata(self, quark: GLib.Quark) -> object:
        """
        This function gets back user data pointers stored via
        g_object_set_qdata().
        """
        ...

    def get_valist(self, first_property_name: str, var_args: list) -> object:
        """
        Gets properties of an object.

        In general, a copy is made of the property contents and the caller
        is responsible for freeing the memory in the appropriate manner for
        the type, for instance by calling g_free() or g_object_unref().

        See g_object_get().
        """
        ...

    def getv(self, n_properties: int, names: object, values: object) -> object:
        """
        Gets @n_properties properties for an @object.
        Obtained properties will be set to @values. All properties must be valid.
        Warnings will be emitted and undefined behaviour may result if invalid
        properties are passed in.
        """
        ...

    def is_floating(self) -> bool:
        """
        Checks whether @object has a [floating][floating-ref] reference.
        """
        ...

    def notify(self, property_name: str) -> object:
        """
        Emits a "notify" signal for the property @property_name on @object.

        When possible, eg. when signaling a property change from within the class
        that registered the property, you should use g_object_notify_by_pspec()
        instead.

        Note that emission of the notify signal may be blocked with
        g_object_freeze_notify(). In this case, the signal emissions are queued
        and will be emitted (in reverse order) when g_object_thaw_notify() is
        called.
        """
        ...

    def notify_by_pspec(self, pspec: ParamSpec) -> object:
        """
        Emits a "notify" signal for the property specified by @pspec on @object.

        This function omits the property name lookup, hence it is faster than
        g_object_notify().

        One way to avoid using g_object_notify() from within the
        class that registered the properties, and using g_object_notify_by_pspec()
        instead, is to store the GParamSpec used with
        g_object_class_install_property() inside a static array, e.g.:

        |[<!-- language="C" -->
          enum
          {
            PROP_0,
            PROP_FOO,
            PROP_LAST
          };

          static GParamSpec *properties[PROP_LAST];

          static void
          my_object_class_init (MyObjectClass *klass)
          {
            properties[PROP_FOO] = g_param_spec_int ("foo", "Foo", "The foo",
                                                     0, 100,
                                                     50,
                                                     G_PARAM_READWRITE);
            g_object_class_install_property (gobject_class,
                                             PROP_FOO,
                                             properties[PROP_FOO]);
          }
        ]|

        and then notify a change on the "foo" property with:

        |[<!-- language="C" -->
          g_object_notify_by_pspec (self, properties[PROP_FOO]);
        ]|
        """
        ...

    def ref(self) -> Object:
        """
        Increases the reference count of @object.

        Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
        of @object will be propagated to the return type (using the GCC typeof()
        extension), so any casting the caller needs to do on the return type must be
        explicit.
        """
        ...

    def ref_sink(self) -> Object:
        """
        Increase the reference count of @object, and possibly remove the
        [floating][floating-ref] reference, if @object has a floating reference.

        In other words, if the object is floating, then this call "assumes
        ownership" of the floating reference, converting it to a normal
        reference by clearing the floating flag while leaving the reference
        count unchanged.  If the object is not floating, then this call
        adds a new normal reference increasing the reference count by one.

        Since GLib 2.56, the type of @object will be propagated to the return type
        under the same conditions as for g_object_ref().
        """
        ...

    def remove_toggle_ref(self, notify: ToggleNotify, data: _T.Optional[object]) -> object:
        """
        Removes a reference added with g_object_add_toggle_ref(). The
        reference count of the object is decreased by one.
        """
        ...

    def remove_weak_pointer(self, weak_pointer_location: object) -> object:
        """
        Removes a weak reference from @object that was previously added
        using g_object_add_weak_pointer(). The @weak_pointer_location has
        to match the one used with g_object_add_weak_pointer().
        """
        ...

    def replace_data(self, key: str, oldval: _T.Optional[object], newval: _T.Optional[object], destroy: _T.Optional[GLib.DestroyNotify], old_destroy: GLib.DestroyNotify) -> bool:
        """
        Compares the user data for the key @key on @object with
        @oldval, and if they are the same, replaces @oldval with
        @newval.

        This is like a typical atomic compare-and-exchange
        operation, for user data on an object.

        If the previous value was replaced then ownership of the
        old value (@oldval) is passed to the caller, including
        the registered destroy notify for it (passed out in @old_destroy).
        Itâ€™s up to the caller to free this as needed, which may
        or may not include using @old_destroy as sometimes replacement
        should not destroy the object in the normal way.

        See g_object_set_data() for guidance on using a small, bounded set of values
        for @key.
        """
        ...

    def replace_qdata(self, quark: GLib.Quark, oldval: _T.Optional[object], newval: _T.Optional[object], destroy: _T.Optional[GLib.DestroyNotify], old_destroy: GLib.DestroyNotify) -> bool:
        """
        Compares the user data for the key @quark on @object with
        @oldval, and if they are the same, replaces @oldval with
        @newval.

        This is like a typical atomic compare-and-exchange
        operation, for user data on an object.

        If the previous value was replaced then ownership of the
        old value (@oldval) is passed to the caller, including
        the registered destroy notify for it (passed out in @old_destroy).
        Itâ€™s up to the caller to free this as needed, which may
        or may not include using @old_destroy as sometimes replacement
        should not destroy the object in the normal way.
        """
        ...

    def run_dispose(self) -> object:
        """
        Releases all references to other objects. This can be used to break
        reference cycles.

        This function should only be called from object system implementations.
        """
        ...

    def set(self, first_property_name: str, *args: object) -> object:
        """
        Sets properties on an object.

        The same caveats about passing integer literals as varargs apply as with
        g_object_new(). In particular, any integer literals set as the values for
        properties of type #gint64 or #guint64 must be 64 bits wide, using the
        %G_GINT64_CONSTANT or %G_GUINT64_CONSTANT macros.

        Note that the "notify" signals are queued and only emitted (in
        reverse order) after all properties have been set. See
        g_object_freeze_notify().
        """
        ...

    def set_data(self, key: str, data: _T.Optional[object]) -> object:
        """
        Each object carries around a table of associations from
        strings to pointers.  This function lets you set an association.

        If the object already had an association with that name,
        the old association will be destroyed.

        Internally, the @key is converted to a #GQuark using g_quark_from_string().
        This means a copy of @key is kept permanently (even after @object has been
        finalized) â€” so it is recommended to only use a small, bounded set of values
        for @key in your program, to avoid the #GQuark storage growing unbounded.
        """
        ...

    def set_data_full(self, key: str, data: _T.Optional[object], destroy: _T.Optional[GLib.DestroyNotify]) -> object:
        """
        Like g_object_set_data() except it adds notification
        for when the association is destroyed, either by setting it
        to a different value or when the object is destroyed.

        Note that the @destroy callback is not called if @data is %NULL.
        """
        ...

    def set_property(self, property_name: str, value: Value) -> object:
        """
        Sets a property on an object.
        """
        ...

    def set_qdata(self, quark: GLib.Quark, data: _T.Optional[object]) -> object:
        """
        This sets an opaque, named pointer on an object.
        The name is specified through a #GQuark (retrieved e.g. via
        g_quark_from_static_string()), and the pointer
        can be gotten back from the @object with g_object_get_qdata()
        until the @object is finalized.
        Setting a previously set user data pointer, overrides (frees)
        the old pointer set, using #NULL as pointer essentially
        removes the data stored.
        """
        ...

    def set_qdata_full(self, quark: GLib.Quark, data: _T.Optional[object], destroy: _T.Optional[GLib.DestroyNotify]) -> object:
        """
        This function works like g_object_set_qdata(), but in addition,
        a void (*destroy) (gpointer) function may be specified which is
        called with @data as argument when the @object is finalized, or
        the data is being overwritten by a call to g_object_set_qdata()
        with the same @quark.
        """
        ...

    def set_valist(self, first_property_name: str, var_args: list) -> object:
        """
        Sets properties on an object.
        """
        ...

    def setv(self, n_properties: int, names: object, values: object) -> object:
        """
        Sets @n_properties properties for an @object.
        Properties to be set will be taken from @values. All properties must be
        valid. Warnings will be emitted and undefined behaviour may result if invalid
        properties are passed in.
        """
        ...

    def steal_data(self, key: str) -> object:
        """
        Remove a specified datum from the object's data associations,
        without invoking the association's destroy handler.
        """
        ...

    def steal_qdata(self, quark: GLib.Quark) -> object:
        """
        This function gets back user data pointers stored via
        g_object_set_qdata() and removes the @data from object
        without invoking its destroy() function (if any was
        set).
        Usually, calling this function is only required to update
        user data pointers with a destroy notifier, for example:
        |[<!-- language="C" -->
        void
        object_add_to_user_list (GObject     *object,
                                 const gchar *new_string)
        {
          // the quark, naming the object data
          GQuark quark_string_list = g_quark_from_static_string ("my-string-list");
          // retrieve the old string list
          GList *list = g_object_steal_qdata (object, quark_string_list);

          // prepend new string
          list = g_list_prepend (list, g_strdup (new_string));
          // this changed 'list', so we need to set it again
          g_object_set_qdata_full (object, quark_string_list, list, free_string_list);
        }
        static void
        free_string_list (gpointer data)
        {
          GList *node, *list = data;

          for (node = list; node; node = node->next)
            g_free (node->data);
          g_list_free (list);
        }
        ]|
        Using g_object_get_qdata() in the above example, instead of
        g_object_steal_qdata() would have left the destroy function set,
        and thus the partial string list would have been freed upon
        g_object_set_qdata_full().
        """
        ...

    def take_ref(self) -> Object:
        """
        If @object is floating, sink it.  Otherwise, do nothing.

        In other words, this function will convert a floating reference (if
        present) into a full reference.

        Typically you want to use g_object_ref_sink() in order to
        automatically do the correct thing with respect to floating or
        non-floating references, but there is one specific scenario where
        this function is helpful.

        The situation where this function is helpful is when creating an API
        that allows the user to provide a callback function that returns a
        GObject. We certainly want to allow the user the flexibility to
        return a non-floating reference from this callback (for the case
        where the object that is being returned already exists).

        At the same time, the API style of some popular GObject-based
        libraries (such as Gtk) make it likely that for newly-created GObject
        instances, the user can be saved some typing if they are allowed to
        return a floating reference.

        Using this function on the return value of the user's callback allows
        the user to do whichever is more convenient for them. The caller will
        alway receives exactly one full reference to the value: either the
        one that was returned in the first place, or a floating reference
        that has been converted to a full reference.

        This function has an odd interaction when combined with
        g_object_ref_sink() running at the same time in another thread on
        the same #GObject instance. If g_object_ref_sink() runs first then
        the result will be that the floating reference is converted to a hard
        reference. If g_object_take_ref() runs first then the result will be
        that the floating reference is converted to a hard reference and an
        additional reference on top of that one is added. It is best to avoid
        this situation.
        """
        ...

    def thaw_notify(self) -> object:
        """
        Reverts the effect of a previous call to
        g_object_freeze_notify(). The freeze count is decreased on @object
        and when it reaches zero, queued "notify" signals are emitted.

        Duplicate notifications for each property are squashed so that at most one
        #GObject::notify signal is emitted for each property, in the reverse order
        in which they have been queued.

        It is an error to call this function when the freeze count is zero.
        """
        ...

    def unref(self) -> object:
        """
        Decreases the reference count of @object. When its reference count
        drops to 0, the object is finalized (i.e. its memory is freed).

        If the pointer to the #GObject may be reused in future (for example, if it is
        an instance variable of another object), it is recommended to clear the
        pointer to %NULL rather than retain a dangling pointer to a potentially
        invalid #GObject instance. Use g_clear_object() for this.
        """
        ...

    def watch_closure(self, closure: Closure) -> object:
        """
        This function essentially limits the life time of the @closure to
        the life time of the object. That is, when the object is finalized,
        the @closure is invalidated by calling g_closure_invalidate() on
        it, in order to prevent invocations of the closure with a finalized
        (nonexisting) object. Also, g_object_ref() and g_object_unref() are
        added as marshal guards to the @closure, to ensure that an extra
        reference count is held on @object during invocation of the
        @closure.  Usually, this function will be called on closures that
        use this @object as closure data.
        """
        ...

    def weak_ref(self, notify: WeakNotify, data: _T.Optional[object]) -> object:
        """
        Adds a weak reference callback to an object. Weak references are
        used for notification when an object is disposed. They are called
        "weak references" because they allow you to safely hold a pointer
        to an object without calling g_object_ref() (g_object_ref() adds a
        strong reference, that is, forces the object to stay alive).

        Note that the weak references created by this method are not
        thread-safe: they cannot safely be used in one thread if the
        object's last g_object_unref() might happen in another thread.
        Use #GWeakRef if thread-safety is required.
        """
        ...

    def weak_unref(self, notify: WeakNotify, data: _T.Optional[object]) -> object:
        """
        Removes a weak reference callback to an object.
        """
        ...


    ...

class ParamSpec(object):
    """
    #GParamSpec is an object structure that encapsulates the metadata
    required to specify parameters, such as e.g. #GObject properties.

    ## Parameter names # {#canonical-parameter-names}

    A property name consists of one or more segments consisting of ASCII letters
    and digits, separated by either the `-` or `_` character. The first
    character of a property name must be a letter. These are the same rules as
    for signal naming (see g_signal_new()).

    When creating and looking up a #GParamSpec, either separator can be
    used, but they cannot be mixed. Using `-` is considerably more
    efficient, and is the â€˜canonical formâ€™. Using `_` is discouraged.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...

    def get_blurb(self) -> str:
        """
        Get the short description of a #GParamSpec.
        """
        ...

    def get_default_value(self) -> Value:
        """
        Gets the default value of @pspec as a pointer to a #GValue.

        The #GValue will remain valid for the life of @pspec.
        """
        ...

    def get_name(self) -> str:
        """
        Get the name of a #GParamSpec.

        The name is always an "interned" string (as per g_intern_string()).
        This allows for pointer-value comparisons.
        """
        ...

    def get_name_quark(self) -> GLib.Quark:
        """
        Gets the GQuark for the name.
        """
        ...

    def get_nick(self) -> str:
        """
        Get the nickname of a #GParamSpec.
        """
        ...

    def get_qdata(self, quark: GLib.Quark) -> object:
        """
        Gets back user data pointers stored via g_param_spec_set_qdata().
        """
        ...

    def get_redirect_target(self) -> ParamSpec:
        """
        If the paramspec redirects operations to another paramspec,
        returns that paramspec. Redirect is used typically for
        providing a new implementation of a property in a derived
        type while preserving all the properties from the parent
        type. Redirection is established by creating a property
        of type #GParamSpecOverride. See g_object_class_override_property()
        for an example of the use of this capability.
        """
        ...

    def ref(self) -> ParamSpec:
        """
        Increments the reference count of @pspec.
        """
        ...

    def ref_sink(self) -> ParamSpec:
        """
        Convenience function to ref and sink a #GParamSpec.
        """
        ...

    def set_qdata(self, quark: GLib.Quark, data: _T.Optional[object]) -> object:
        """
        Sets an opaque, named pointer on a #GParamSpec. The name is
        specified through a #GQuark (retrieved e.g. via
        g_quark_from_static_string()), and the pointer can be gotten back
        from the @pspec with g_param_spec_get_qdata().  Setting a
        previously set user data pointer, overrides (frees) the old pointer
        set, using %NULL as pointer essentially removes the data stored.
        """
        ...

    def set_qdata_full(self, quark: GLib.Quark, data: _T.Optional[object], destroy: _T.Optional[GLib.DestroyNotify]) -> object:
        """
        This function works like g_param_spec_set_qdata(), but in addition,
        a `void (*destroy) (gpointer)` function may be
        specified which is called with @data as argument when the @pspec is
        finalized, or the data is being overwritten by a call to
        g_param_spec_set_qdata() with the same @quark.
        """
        ...

    def sink(self) -> object:
        """
        The initial reference count of a newly created #GParamSpec is 1,
        even though no one has explicitly called g_param_spec_ref() on it
        yet. So the initial reference count is flagged as "floating", until
        someone calls `g_param_spec_ref (pspec); g_param_spec_sink
        (pspec);` in sequence on it, taking over the initial
        reference count (thus ending up with a @pspec that has a reference
        count of 1 still, but is not flagged "floating" anymore).
        """
        ...

    def steal_qdata(self, quark: GLib.Quark) -> object:
        """
        Gets back user data pointers stored via g_param_spec_set_qdata()
        and removes the @data from @pspec without invoking its destroy()
        function (if any was set).  Usually, calling this function is only
        required to update user data pointers with a destroy notifier.
        """
        ...

    def unref(self) -> object:
        """
        Decrements the reference count of a @pspec.
        """
        ...


    ...

class ParamSpecBoolean(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for boolean properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecBoxed(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for boxed properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecChar(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for character properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecDouble(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for double properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecEnum(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for enum
    properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecFlags(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for flags
    properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecFloat(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for float properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecGType(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for #GType properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecInt(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for integer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecInt64(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for 64bit integer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecLong(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for long integer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecObject(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for object properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecOverride(ParamSpec):
    """
    A #GParamSpec derived structure that redirects operations to
    other types of #GParamSpec.

    All operations other than getting or setting the value are redirected,
    including accessing the nick and blurb, validating a value, and so
    forth.

    See g_param_spec_get_redirect_target() for retrieving the overridden
    property. #GParamSpecOverride is used in implementing
    g_object_class_override_property(), and will not be directly useful
    unless you are implementing a new base type similar to GObject.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecParam(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
    properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecPointer(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for pointer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecString(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for string
    properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecUChar(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for unsigned character properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecUInt(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for unsigned integer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecUInt64(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecULong(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecUnichar(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecValueArray(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for #GValueArray properties.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class ParamSpecVariant(ParamSpec):
    """
    A #GParamSpec derived structure that contains the meta data for #GVariant properties.

    When comparing values with g_param_values_cmp(), scalar values with the same
    type will be compared with g_variant_compare(). Other non-%NULL variants will
    be checked for equality with g_variant_equal(), and their sort order is
    otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL
    values compare equal.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    ...

class SignalGroup(Object):
    """
    #GSignalGroup manages to simplify the process of connecting
    many signals to a #GObject as a group. As such there is no API
    to disconnect a signal from the group.

    In particular, this allows you to:

     - Change the target instance, which automatically causes disconnection
       of the signals from the old instance and connecting to the new instance.
     - Block and unblock signals as a group
     - Ensuring that blocked state transfers across target instances.

    One place you might want to use such a structure is with #GtkTextView and
    #GtkTextBuffer. Often times, you'll need to connect to many signals on
    #GtkTextBuffer from a #GtkTextView subclass. This allows you to create a
    signal group during instance construction, simply bind the
    #GtkTextView:buffer property to #GSignalGroup:target and connect
    all the signals you need. When the #GtkTextView:buffer property changes
    all of the signals will be transitioned correctly.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...


    @classmethod
    def new(cls, target_type: Type) -> SignalGroup:
        """
        Creates a new #GSignalGroup for target instances of @target_type.
        """
        ...

    def block(self) -> object:
        """
        Blocks all signal handlers managed by @self so they will not
        be called during any signal emissions. Must be unblocked exactly
        the same number of times it has been blocked to become active again.

        This blocked state will be kept across changes of the target instance.
        """
        ...

    def connect(self, detailed_signal: str, c_handler: Callback, data: _T.Optional[object]) -> object:
        """
        Connects @c_handler to the signal @detailed_signal
        on the target instance of @self.

        You cannot connect a signal handler after #GSignalGroup:target has been set.
        """
        ...

    def connect_after(self, detailed_signal: str, c_handler: Callback, data: _T.Optional[object]) -> object:
        """
        Connects @c_handler to the signal @detailed_signal
        on the target instance of @self.

        The @c_handler will be called after the default handler of the signal.

        You cannot connect a signal handler after #GSignalGroup:target has been set.
        """
        ...

    def connect_data(self, detailed_signal: str, c_handler: Callback, data: _T.Optional[object], notify: ClosureNotify, flags: ConnectFlags) -> object:
        """
        Connects @c_handler to the signal @detailed_signal
        on the target instance of @self.

        You cannot connect a signal handler after #GSignalGroup:target has been set.
        """
        ...

    def connect_object(self, detailed_signal: str, c_handler: Callback, object: object, flags: ConnectFlags) -> object:
        """
        Connects @c_handler to the signal @detailed_signal on #GSignalGroup:target.

        Ensures that the @object stays alive during the call to @c_handler
        by temporarily adding a reference count. When the @object is destroyed
        the signal handler will automatically be removed.

        You cannot connect a signal handler after #GSignalGroup:target has been set.
        """
        ...

    def connect_swapped(self, detailed_signal: str, c_handler: Callback, data: _T.Optional[object]) -> object:
        """
        Connects @c_handler to the signal @detailed_signal
        on the target instance of @self.

        The instance on which the signal is emitted and @data
        will be swapped when calling @c_handler.

        You cannot connect a signal handler after #GSignalGroup:target has been set.
        """
        ...

    def dup_target(self) -> Object:
        """
        Gets the target instance used when connecting signals.
        """
        ...

    def set_target(self, target: _T.Optional[Object]) -> object:
        """
        Sets the target instance used when connecting signals. Any signal
        that has been registered with g_signal_group_connect_object() or
        similar functions will be connected to this object.

        If the target instance was previously set, signals will be
        disconnected from that object prior to connecting to @target.
        """
        ...

    def unblock(self) -> object:
        """
        Unblocks all signal handlers managed by @self so they will be
        called again during any signal emissions unless it is blocked
        again. Must be unblocked exactly the same number of times it
        has been blocked to become active again.
        """
        ...


    ...

class TypeModule(Object, TypePlugin):
    """
    #GTypeModule provides a simple implementation of the #GTypePlugin
    interface.

    The model of #GTypeModule is a dynamically loaded module which
    implements some number of types and interface implementations.

    When the module is loaded, it registers its types and interfaces
    using g_type_module_register_type() and g_type_module_add_interface().
    As long as any instances of these types and interface implementations
    are in use, the module is kept loaded. When the types and interfaces
    are gone, the module may be unloaded. If the types and interfaces
    become used again, the module will be reloaded. Note that the last
    reference cannot be released from within the module code, since that
    would lead to the caller's code being unloaded before g_object_unref()
    returns to it.

    Keeping track of whether the module should be loaded or not is done by
    using a use count - it starts at zero, and whenever it is greater than
    zero, the module is loaded. The use count is maintained internally by
    the type system, but also can be explicitly controlled by
    g_type_module_use() and g_type_module_unuse(). Typically, when loading
    a module for the first type, g_type_module_use() will be used to load
    it so that it can initialize its types. At some later point, when the
    module no longer needs to be loaded except for the type
    implementations it contains, g_type_module_unuse() is called.

    #GTypeModule does not actually provide any implementation of module
    loading and unloading. To create a particular module type you must
    derive from #GTypeModule and implement the load and unload functions
    in #GTypeModuleClass.
    """

    def __init__(self, *args: object, **kwargs: object) -> None:
        ...

    def add_interface(self, instance_type: Type, interface_type: Type, interface_info: InterfaceInfo) -> object:
        """
        Registers an additional interface for a type, whose interface lives
        in the given type plugin. If the interface was already registered
        for the type in this plugin, nothing will be done.

        As long as any instances of the type exist, the type plugin will
        not be unloaded.

        Since 2.56 if @module is %NULL this will call g_type_add_interface_static()
        instead. This can be used when making a static build of the module.
        """
        ...

    def register_enum(self, name: str, const_static_values: EnumValue) -> Type:
        """
        Looks up or registers an enumeration that is implemented with a particular
        type plugin. If a type with name @type_name was previously registered,
        the #GType identifier for the type is returned, otherwise the type
        is newly registered, and the resulting #GType identifier returned.

        As long as any instances of the type exist, the type plugin will
        not be unloaded.

        Since 2.56 if @module is %NULL this will call g_type_register_static()
        instead. This can be used when making a static build of the module.
        """
        ...

    def register_flags(self, name: str, const_static_values: FlagsValue) -> Type:
        """
        Looks up or registers a flags type that is implemented with a particular
        type plugin. If a type with name @type_name was previously registered,
        the #GType identifier for the type is returned, otherwise the type
        is newly registered, and the resulting #GType identifier returned.

        As long as any instances of the type exist, the type plugin will
        not be unloaded.

        Since 2.56 if @module is %NULL this will call g_type_register_static()
        instead. This can be used when making a static build of the module.
        """
        ...

    def register_type(self, parent_type: Type, type_name: str, type_info: TypeInfo, flags: TypeFlags) -> Type:
        """
        Looks up or registers a type that is implemented with a particular
        type plugin. If a type with name @type_name was previously registered,
        the #GType identifier for the type is returned, otherwise the type
        is newly registered, and the resulting #GType identifier returned.

        When reregistering a type (typically because a module is unloaded
        then reloaded, and reinitialized), @module and @parent_type must
        be the same as they were previously.

        As long as any instances of the type exist, the type plugin will
        not be unloaded.

        Since 2.56 if @module is %NULL this will call g_type_register_static()
        instead. This can be used when making a static build of the module.
        """
        ...

    def set_name(self, name: str) -> object:
        """
        Sets the name for a #GTypeModule
        """
        ...

    def unuse(self) -> object:
        """
        Decreases the use count of a #GTypeModule by one. If the
        result is zero, the module will be unloaded. (However, the
        #GTypeModule will not be freed, and types associated with the
        #GTypeModule are not unregistered. Once a #GTypeModule is
        initialized, it must exist forever.)
        """
        ...

    def use(self) -> bool:
        """
        Increases the use count of a #GTypeModule by one. If the
        use count was zero before, the plugin will be loaded.
        If loading the plugin fails, the use count is reset to
        its prior value.
        """
        ...


    ...


